# 1 智能指针

- 显示的堆内存管理存在的问题：

> 野指针：内存单元已经被释放，指向它的指针却还在使用。
> 
> 重复释放：释放已经被释放的内存单元，或释放已经被重新分配过的内存单元。
> 
> 内存泄漏，分配的内存用完后没有释放，导致内存占用剧增，即内存泄漏。

智能指针是针对我们从堆上申请的空间，比如：new和malloc出来的空间。使得智能指针来帮我们释放空间，不需要我们来手动释放了。

- RAII

RAII是一种了利用对象生命周期来控制程序资源(如：内存，文件，套接字，互斥量等)的技术。在对象构造时获得资源，使得堆资源的控制在对象的生命周期内都有效，最后在对象析构的时候释放资源。实际上我们是将资源的管理托管给了一个对象。

这样做有两个好处：

> 不需要显示的释放资源。
> 
> 资源的控制在对象生命周期内都有效。

智能指针利用RAII思想并重载了指针的操作符 * 和 -> 。

```cpp
template<class T>
class SmatrPrt{
private:
	  T* _ptr;
public:
	  SmatrPrt(T* ptr = nullptr)
	    	:_ptr(ptr)	{}
        
    T& operator*()  { return *_ptr; }
	  T* operator->()  { return _ptr; }
  	
    ~SmatrPrt(){
    		if (_ptr){
       			cout << "delete ptr" << endl;
	      		delete _ptr;
    		}
  	}
};

- auto_ptr

auto_ptr不能共享所有权。原对象拷贝给新对象的时候，原对象就会被设置为nullptr，此时就只有新对象指向一块资源空间。

如果auto_ptr调用拷贝构造函数或者赋值重载函数后，如果再去使用原来的对象的话，那么整个程序就会崩溃掉，因为原来的对象被设置为nullptr。

auto_ptr不能指向数组

auto_ptr不能作为容器成员

auto_ptr不能通过赋值操作来初始化

> std::auto_ptr<int> p = new int(42)//错

> std::auto_ptr<int> p new int(42)//对

- unique_ptr

unique_ptr可以看成是auto_ptr的替代品，同一时间只能有一个智能指针可以指向该对象，因为无法进行拷贝构造和拷贝赋值，但是可以进行移动构造和移动赋值。

- share_ptr

在类中增加一个成员变量用来计数。每次调用一次拷贝构造和赋值重载函数，即每增加一个管理者，计数加1。没析构一个管理者对象，计数器减1，直到减为0，才真正释放资源。

shared_ptr采用的是引用计数原理来实现多个shared_ptr对象之间共享资源：

> 构造函数中计数初始化为1；
>
> 拷贝构造函数中计数值加1；
>
> 赋值运算符中，左边的对象引用计数减1，右边的对象引用计数加1；
>
> 析构函数中引用计数减1；
>
> 在赋值运算符和析构函数中，如果减1后为0，则调用delete释放对象。

> shared_ptr在内部会维护着一份引用计数，用来记录该份资源被几个对象共享。
>
> 当一个shared_ptr对象被销毁时（调用析构函数），析构函数内就会将该计数减1。
>
> 如果引用计数减为0后，则表示自己是最后一个使用该资源的shared_ptr对象，必须释放资源。
>
> 如果引用计数不是0，就说明自己还有其他对象在使用，则不能释放该资源，否则其他对象就成为野指针。
>
> 引用计数是用来记录资源对象中有多少个指针指向该资源对象。

当两个share_ptr相互引用时会造成循环引用。创建智能指针时计数器+1，引用时+1，析构时释放一次，计数器为1，导致所引用的对象不会被释放，即两个指针死锁了。

- weak_ptr

weak_ptr类的对象它可以指向shared_ptr，并且不会改变shared_ptr的引用计数。一旦最后一个shared_ptr被销毁时，对象就会被释放。

weak_ptr并没有重载operator-> 和operator* 操作符，因此不可直接通过weak_ptr使用对象

提供了expired() 与 lock() 成员函数前者用于判断weak_ptr指向的对象是否已被销毁

# 2 auto



# 3 decltype

# 4 nullptr


# 5 右值引用

右值引用的主要目的是为了实现转移语义和完美转发，消除两个对象交互时不必要的对象拷贝，也能够更加简洁明确地定义泛型函数

# 6 lambda

# 7 列表初始化

# 8 for循环

# 9 线程


