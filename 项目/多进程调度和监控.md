# 1 调度程序
```cpp
int main(int argc,char* argv[])
{
    // 关闭信号和IO
    for(int i=0;i<64;i++)
    {   
        signal(i,SIG_IGN); //close(i);
    }
    // 生成子进程，父进程退出
    if(fork()>0) exit(0);
    signal(SIGCHLD,SIG_IGN);
    // 去除调度程序的参数
    char* pargv[argc];
    for(int i=0;i<argc;i++)
    {
        pargv[i] = argv[i+2];
    }
    pargv[argc-2] = NULL;
    while(true)
    {
        if(fork()==0)
        {
            execv(argv[2],pargv);
            exit(0);
        }
        else
        {
            int status = 0;
            wait(&status);
            sleep(atoi(argv[1]));
        }
    }
}
```

# 2 心跳机制
```cpp
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <time.h>

#define MAXNUMP    1000
#define SHMKEYP  0x5095

// 心跳信息的结构体
struct st_pinfo
{   
    int    pid;         // 进程id
    char*  pname[51];   // 进程名称，可以为空
    int    timeout;     // 超时时间
    time_t atime;       // 最后心跳时间
};
 
int main(int argc,char* argv[])
{
    // 0.帮助文档
    if(argc<2) {printf("./sem progress\n");  return -1;}

    // 1.创建/获取共享内存，大小为n*sizeof(struct st_pinfo)
    int m_shmid = 0;
    if((m_shmid=shmget(MAXNUMP,SHMKEYP,0640|IPC_CREAT)) == -1)
    {printf("shmget failed.\n");  return -1;}
 
    // 2.共享内存链接到当前进程地址空间
    struct st_pinfo *m_shm;
    m_shm = (struct st_pinfo *)shmat(m_shmid,0,0);

    // 3.创建当前进程心跳信息结构体变量，把本体的信息填进去
    struct st_pinfo stpinfo;
    memset(&stpinfo,0,sizeof(struct st_pinfo));
    stpinfo.pid = getpid();
    stpinfo.timeout = 30;
    stpinfo.atime = time(0);

    // 加锁
    // 4.在共享内中找一个空位置，填进去
    int pos = -1;   // 记录找到的空位置
    for(int i=0;i<MAXNUMP;i++)
    {if(m_shm[i].pid == stpinfo.pid)  pos = i; break;} // 防止其他进程残留信息

    for(int i=0;i<MAXNUMP;i++)
    {
        if(m_shm[i].pid == 0)
        {
            pos = i; break;
        }
    }
    if(pos == -1)
    {
        printf("共享内存空间已用完.\n");    // 解锁
    }
    memcpy(m_shm+pos,&stpinfo,sizeof(struct st_pinfo));
    // 解锁

    while(true)
    {  
        // 更新共享内存中本进程的心跳时间
        m_shm[pos].atime = time(0);
        // 执行业务代码，必要时在处理业务过程中更新心跳时间
        sleep(10);
    }
    // 退出时把当前进程从内存中移走
    memset(m_shm+pos,0,sizeof(struct st_pinfo));

    // 把共享内存从当前进程分离
    shmdt(m_shm);

    return 0;
}
```
# 守护进程
本程序用于检查后台服务程序是否超时，如果已超时，就终止它。被终止后调度程序会重新调用程序。

- 1）该程序由调度程序启动，运行周期建议10秒
- 2）为了避免被普通用户误杀，本程序应该用root用户启动。
- 3）如果要停止本程序，只能用killall -9 终止。

> exit退出时不会调用局部类对象的析构函数
> 
> return退出时会调用

```cpp
#include "_public.h"

// 程序运行的日志。
CLogFile logfile;

int main(int argc,char *argv[])
{
  // 程序的帮助。
  if (argc != 2)
  {
    // ./checkproc logfilename
    // procctl 10 checkproc checkproc.log\n\n");
    return 0;
  }

  // 忽略全部的信号和IO，不希望程序被干扰。
  CloseIOAndSignal(true);

  // 打开日志文件。
  if (logfile.Open(argv[1],"a+")==false)
  { printf("logfile.Open(%s) failed.\n",argv[1]); return -1; }

  int shmid=0;

  // 创建/获取共享内存，键值为SHMKEYP，大小为MAXNUMP个st_procinfo结构体的大小。
  if ( (shmid = shmget((key_t)SHMKEYP, MAXNUMP*sizeof(struct st_procinfo), 0666|IPC_CREAT)) == -1)
  {
    logfile.Write("创建/获取共享内存(%x)失败。\n",SHMKEYP); return false;
  }

  // 将共享内存连接到当前进程的地址空间。
  struct st_procinfo *shm=(struct st_procinfo *)shmat(shmid, 0, 0);

  // 遍历共享内存中全部的记录。
  for (int ii=0;ii<MAXNUMP;ii++)
  {
    // 如果记录的pid==0，表示空记录，continue;
    if (shm[ii].pid==0) continue;

    // 如果记录的pid!=0，表示是服务程序的心跳记录。

    // 程序稳定运行后，以下两行代码可以注释掉。
    //logfile.Write("ii=%d,pid=%d,pname=%s,timeout=%d,atime=%d\n",\
    //               ii,shm[ii].pid,shm[ii].pname,shm[ii].timeout,shm[ii].atime);

    // 向进程发送信号0，判断它是否还存在，如果不存在，从共享内存中删除该记录，continue;
    int iret=kill(shm[ii].pid,0);
    if (iret==-1)
    {
      logfile.Write("进程pid=%d(%s)已经不存在。\n",(shm+ii)->pid,(shm+ii)->pname);
      memset(shm+ii,0,sizeof(struct st_procinfo)); // 从共享内存中删除该记录。
      continue;
    }

    time_t now=time(0);   // 取当前时间。

    // 如果进程未超时，continue;
    if (now-shm[ii].atime<shm[ii].timeout) continue;

    // 如果已超时。
    logfile.Write("进程pid=%d(%s)已经超时。\n",(shm+ii)->pid,(shm+ii)->pname);
 
    // 发送信号15，尝试正常终止进程。
    kill(shm[ii].pid,15);

    // 每隔1秒判断一次进程是否存在，累计5秒，一般来说，5秒的时间足够让进程退出。
    for (int jj=0;jj<5;jj++)
    {
      sleep(1);
      iret=kill(shm[ii].pid,0);     // 向进程发送信号0，判断它是否还存在。
      if (iret==-1) break;     // 进程已退出。
    }

    // 如果进程仍存在，就发送信号9，强制终止它。
    if (iret==-1)
      logfile.Write("进程pid=%d(%s)已经正常终止。\n",(shm+ii)->pid,(shm+ii)->pname);
    else
    {
      kill(shm[ii].pid,9);  // 如果进程仍存在，就发送信号9，强制终止它。
      logfile.Write("进程pid=%d(%s)已经强制终止。\n",(shm+ii)->pid,(shm+ii)->pname);
    }

    // 从共享内存中删除已超时进程的心跳记录。
    memset(shm+ii,0,sizeof(struct st_procinfo)); // 从共享内存中删除该记录。
  }

  // 把共享内存从当前进程中分离。
  shmdt(shm);

  return 0;
}
```

























