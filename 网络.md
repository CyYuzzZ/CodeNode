# 1. 网络编程

创建socket
```cpp
socket()
```
 
- 忽略SIGPIPE信号

> 当通信一端断开连接时，系统会发送SIGPIPE信号，默认是关闭进程，程序应当在检测到对方断开连接时做出相应处理，而不是任由系统关闭程序。

- 打开SO_REUSEADDR选项

> socket服务端一定要打开这个选项，否则bind()可能不成功：Address already in use。

```cpp
char opt = 1; usigned int len = sizeof(opt);
setsockopt(listenfd,SOL_SOCKET,SO_REUSEADDR,&opt,len); 
```

## 长连接

> 在同一网段内部，网络设备不会断开空闲的链接。
> 在不同网段之间网络设备会断开连接，超时时间1-5分钟。
> 网络服务程序心跳的超时时间一般设置在50-120秒之间。


# 2. 网络分层结构

- 五层模型：应用层、传输层、网络层、数据链路层、物理层。

> 应用层：为应用程序提供交互服务。在互联网中的应用层协议很多，如域名系统DNS、HTTP协议、SMTP协议等。
> 
> 传输层：负责向两台主机进程之间的通信提供数据传输服务。传输层的协议主要有传输控制协议TCP和用户数据协议UDP。
> 
> 网络层：选择合适的路由和交换结点，确保数据及时传送。主要包括IP协议。
> 
> 数据链路层：在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。
> 
> 物理层：实现相邻节点间比特流的透明传输，尽可能屏蔽传输介质和物理设备的差异。

# 3. 三次握手

![image](https://user-images.githubusercontent.com/72682213/189035299-66f5e0d5-e1b6-4732-8b90-5736a3923a36.png)

第一次握手：客户端向服务端发起建立连接请求，客户端会随机生成一个起始序列号x，客户端向服务端发送的字段中包含标志位SYN=1，序列号seq=x。第一次握手前客户端的状态为CLOSE，第一次握手后客户端的状态为SYN-SENT。此时服务端的状态为LISTEN。

第二次握手：服务端在收到客户端发来的报文后，会随机生成一个服务端的起始序列号y，然后给客户端回复一段报文，其中包括标志位SYN=1，ACK=1，序列号seq=y，确认号ack=x+1。第二次握手前服务端的状态为LISTEN，第二次握手后服务端的状态为SYN-RCVD，此时客户端的状态为SYN-SENT。（其中SYN=1表示要和客户端建立一个连接，ACK=1表示确认序号有效）

第三次握手：客户端收到服务端发来的报文后，会再向服务端发送报文，其中包含标志位ACK=1，序列号seq=x+1，确认号ack=y+1。第三次握手前客户端的状态为SYN-SENT，第三次握手后客户端和服务端的状态都为ESTABLISHED。此时连接建立完成。



# 3. TCP沾包

- 原因：

TCP是一个基于字节流的传输服务（UDP基于报文的），“流” 意味着TCP所传输的数据是没有边界的。所以可能会出现两个数据包粘在一起的情况。 

当发送的数据包过小时（小于套接字缓冲区的大小），TCP协议默认的会启用Nagle算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。

接收方采用TCP协议接收数据时的过程是这样的：数据到接收方，从网络模型的下方传递至传输层，传输层的TCP协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C语言用recv、read等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 > 应用层拿数据速度）

- 解决：
> 1. 发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。
> 
> 2. 包头加上包体长度。包头是定长的4个字节，说明了包体的长度。接收方先接收包头长度，依据包头长度来接收包体。
> 
> 3. 在数据包之间设置边界，如添加特殊符号\r\n标记。FTP协议正是这么做的。但问题在于如果数据正文中也含有\r\n，则会误判为消息的边界。
> 
> 4. 使用更加复杂的应用层协议。


- 为什么等缓冲区满了才发送?

缓冲区的优势以文件流的写入为例，如果我们不使用缓冲区，每次写操作CPU都会和低速存储设备也就是磁盘进行交互，那么整个写入文件的速度就会受制于低速的存储设备（磁盘）。但如果使用缓冲区的话，每次写操作会先将数据保存在高速缓冲区内存上，当缓冲区的数据到达某个阈值之后，再将文件一次性写入到磁盘上。因为内存的写入速度远远大于磁盘的写入速度，所以当有了缓冲区之后，文件的写入速度就被大大提升了。


# 2.为什么需要三次握手？两次不行？
 
三次握手过程：

> 1、第一次握手：客户端给服务器发送一个SYN报文，说明客户端请求建立连接。
> 
> 2、第二次握手：服务器收到SYN，回复SYN（同步标志位）+ACK（确认标志位）报文，同意建立连接。
> 
> 3、第三次握手：客户端收到SYN+ACK报文之后，回复ACK给服务端（表示客户端收到了服务端发的同意报文）。
> 
> 4、服务器收到ACK报文之后，三次握手建立完成。

原因：

> 1、因为信道不可靠，而 TCP 想在不可靠信道上建立可靠地传输，那么三次通信是理论上的最小值。（而 UDP 则不需建立可靠传输，因此 UDP 不需要三次握手。）
> 
> 2、双方都需要确认对方收到了自己发送的序列号，确认过程最少要进行三次通信。
> 
> 3、为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。


# 3. 为什么需要四次挥手？三次不行？
 









# 2. TCP协议如何保证可靠传输

可靠传输有如下两个特点：

> a.传输信道无差错,保证传输数据正确；
> 
> b.不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据（流量控制）。

- （1）采用三次握手来建立TCP连接，四次挥手来释放TCP连接，从而保证建立的传输信道是可靠的。
- （2）TCP采用了连续ARQ协议（回退N，Go-back-N；超时自动重传）来保证数据传输的正确性，使用滑动窗口协议保证接收方能够及时处理所接收到的数据，进行流量控制。


数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时 TCP 发送数据端超时后会重发数据。

对失序数据包重排序：既然 TCP 报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序，因此 TCP 报文段的到达也可能会失序。TCP 将对失序数据进行重新排序，然后才交给应用层；
丢弃重复数据：对于重复数据，能够丢弃重复数据。

应答机制：当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒。

超时重发：当TCP发出一个段后，启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。

- （3）最后，TCP使用慢开始、拥塞避免、快重传和快恢复来进行拥塞控制，避免网络拥塞。


TCP是面向连接的、可靠的、传输层通信协议。可靠体现在：
有状态：TCP会确认发送了哪些报文，接收方受到了哪些报文，哪些没有收到，保证数据包按序到达，不允许有差错。
可控制：如果出现丢包或者网络状况不佳，则会跳转自己的行为，减少发送的速度或者重发，所以上面能保证数据包的有效传输。




算机网络：HTTP，HTTP请求报文格式、GET和POST、TCP三次握手、TCP和UDP
作者：zhusers
链接：https://www.nowcoder.com/discuss/1030526?type=0&channel=-1&source_id=discuss_terminal_discuss_hot_nctrack
来源：牛客网

1、TCP、UDP可以绑定相同的端口吗？多个TCP进程可以绑定同一个端口吗？
2、什么情况下，可以重新利用这个端口？
3、介绍一下time_wait是一个什么状态，为什么需要这个状态，有什么作用？
4、time_wait状态会带来什么副作用吗？
5、同步IO和异步IO介绍一下？
