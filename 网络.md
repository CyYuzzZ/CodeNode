# 1. 网络编程

创建socket
```cpp
socket()
```
 
- 忽略SIGPIPE信号

> 当通信一端断开连接时，系统会发送SIGPIPE信号，默认是关闭进程，程序应当在检测到对方断开连接时做出相应处理，而不是任由系统关闭程序。

- 打开SO_REUSEADDR选项

> socket服务端一定要打开这个选项，否则bind()可能不成功：Address already in use。

```cpp
char opt = 1; usigned int len = sizeof(opt);
setsockopt(listenfd,SOL_SOCKET,SO_REUSEADDR,&opt,len); 
```

## 长连接

> 在同一网段内部，网络设备不会断开空闲的链接。
> 在不同网段之间网络设备会断开连接，超时时间1-5分钟。
> 网络服务程序心跳的超时时间一般设置在50-120秒之间。


# 2. 网络分层结构

- 五层模型：应用层、传输层、网络层、数据链路层、物理层。

> 应用层：为应用程序提供交互服务。在互联网中的应用层协议很多，如域名系统DNS、HTTP协议、SMTP协议等。
> 
> 传输层：负责向两台主机进程之间的通信提供数据传输服务。传输层的协议主要有传输控制协议TCP和用户数据协议UDP。
> 
> 网络层：选择合适的路由和交换结点，确保数据及时传送。主要包括IP协议。
> 
> 数据链路层：在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。
> 
> 物理层：实现相邻节点间比特流的透明传输，尽可能屏蔽传输介质和物理设备的差异。

# 3. 三次握手，两次？

![image](https://user-images.githubusercontent.com/72682213/189035299-66f5e0d5-e1b6-4732-8b90-5736a3923a36.png)

- 第一次握手：客户端向服务端发起建立连接请求，客户端会随机生成一个起始序列号x，客户端向服务端发送的字段中包含标志位SYN=1，序列号seq=x。第一次握手前客户端的状态为CLOSE，第一次握手后客户端的状态为SYN-SENT。此时服务端的状态为LISTEN。

- 第二次握手：服务端在收到客户端发来的报文后，会随机生成一个服务端的起始序列号y，然后给客户端回复一段报文，其中包括标志位SYN=1，ACK=1，序列号seq=y，确认号ack=x+1。第二次握手前服务端的状态为LISTEN，第二次握手后服务端的状态为SYN-RCVD，此时客户端的状态为SYN-SENT。（其中SYN=1表示要和客户端建立一个连接，ACK=1表示确认序号有效）

- 第三次握手：客户端收到服务端发来的报文后，会再向服务端发送报文，其中包含标志位ACK=1，序列号seq=x+1，确认号ack=y+1。第三次握手前客户端的状态为SYN-SENT，第三次握手后客户端和服务端的状态都为ESTABLISHED。此时连接建立完成。

> 第三次握手主要为了防止已失效的连接请求报文段突然又传输到了服务端，导致产生问题。
>
> 比如客户端A发出连接请求，可能因为网络阻塞原因，A没有收到确认报文，于是A再重传一次连接请求。
>
> 连接成功，等待数据传输完毕后，就释放了连接。
>
> 然后A发出的第一个连接请求等到连接释放以后的某个时间才到达服务端B，此时B误认为A又发出一次新的连接请求，于是就向A发出确认报文段。
>
> 如果不采用三次握手，只要B发出确认，就建立新的连接了，此时A不会响应B的确认且不发送数据，则B一直等待A发送数据，浪费资源。







三次握手过程：

> 1、第一次握手：客户端给服务器发送一个SYN报文，说明客户端请求建立连接。
> 
> 2、第二次握手：服务器收到SYN，回复SYN（同步标志位）+ACK（确认标志位）报文，同意建立连接。
> 
> 3、第三次握手：客户端收到SYN+ACK报文之后，回复ACK给服务端（表示客户端收到了服务端发的同意报文）。
> 
> 4、服务器收到ACK报文之后，三次握手建立完成。

原因：

> 1、因为信道不可靠，而 TCP 想在不可靠信道上建立可靠地传输，那么三次通信是理论上的最小值。（而 UDP 则不需建立可靠传输，因此 UDP 不需要三次握手。）
> 
> 2、双方都需要确认对方收到了自己发送的序列号，确认过程最少要进行三次通信。
> 
> 3、为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。



# 4. 四次挥手

![image](https://user-images.githubusercontent.com/72682213/189035597-5876ac39-0afd-4185-b9c9-cb7bbd508aa8.png)

- A的应用进程先向其TCP发出连接释放报文段（FIN=1，seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN-WAIT-1（终止等待1）状态，等待B的确认。

- B收到连接释放报文段后即发出确认报文段（ACK=1，ack=u+1，seq=v），B进入CLOSE-WAIT（关闭等待）状态，此时的TCP处于半关闭状态，A到B的连接释放。

- A收到B的确认后，进入FIN-WAIT-2（终止等待2）状态，等待B发出的连接释放报文段。

- B发送完数据，就会发出连接释放报文段（FIN=1，ACK=1，seq=w，ack=u+1），B进入LAST-ACK（最后确认）状态，等待A的确认。

- A收到B的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），A进入TIME-WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL（最大报文段生存时间）后，A才进入CLOSED状态。B收到A发出的确认报文段后关闭连接，若没收到A发出的确认报文段，B就会重传连接释放报文段。


- 第四次挥手为什么要等待2MSL？

保证A发送的最后一个ACK报文段能够到达B。这个ACK报文段有可能丢失，B收不到这个确认报文，就会超时重传连接释放报文段，然后A可以在2MSL时间内收到这个重传的连接释放报文段，接着A重传一次确认，重新启动2MSL计时器，最后A和B都进入到CLOSED状态，若A在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到B重传的连接释放报文段，所以不会再发送一次确认报文段，B就无法正常进入到CLOSED状态。

防止已失效的连接请求报文段出现在本连接中。A在发送完最后一个ACK报文段后，再经过2MSL，就可以使这个连接所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现旧的连接请求报文段。

- 为什么是四次挥手

因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。但是在关闭连接时，当Server端收到Client端发出的连接释放报文时，很可能并不会立即关闭SOCKET，所以Server端先回复一个ACK报文，告诉Client端我收到你的连接释放报文了。只有等到Server端所有的报文都发送完了，这时Server端才能发送连接释放报文，之后两边才会真正的断开连接。故需要四次挥手。

# 4. TCP/UDP特点

| TCP | UDP |
|-|-|
|面向连接的运输层协议                       | 无连接的，即发送数据之前不需要建立连接|
|可靠交付的服务                                |不保证可靠交付|
|面向字节流,把数据看成一连串无结构的字节流   |面向报文|
|每一条TCP连接只能是点到点的                |支持一对一、一对多、多对一和多对多的通信方式|
|有拥塞控制|  没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如实时视频会议等）    |
|首部20个字节|首部8个字节|
|全双工通信|          |


# 5. TCP报文首部

![image](https://user-images.githubusercontent.com/72682213/189035937-0ea0caac-bc00-4915-8c0d-85b2542b17f5.png)

- 16位端口号：源端口号，主机该报文段是来自哪里；目标端口号，要传给哪个上层协议或应用程序

- 32位序号：一次TCP通信（从TCP连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。

- 32位确认号：用作对另一方发送的tcp报文段的响应。其值是收到的TCP报文段的序号值加1。

- 4位头部长度：表示tcp头部有多少个32bit字（4字节）。因为4位最大能标识15，所以TCP头部最长是60字节。

- 6位标志位：URG(紧急指针是否有效)，ACk（表示确认号是否有效），PSH（缓冲区尚未填满），RST（表示要求对方重新建立连接），SYN（建立连接消息标志接），FIN（表示告知对方本端要关闭连接了）

- 16位窗口大小：是TCP流量控制的一个手段。这里说的窗口，指的是接收通告窗口。它告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。

- 16位校验和：由发送端填充，接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。注意，这个校验不仅包括TCP头部，也包括数据部分。这也是TCP可靠传输的一个重要保障。

- 16位紧急指针：一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP的紧急指针是发送端向接收端发送紧急数据的方法。

# 6. TCP和UDP应用层协议、应用场景

 - 基于TCP的应用层协议有：HTTP、FTP、SMTP、TELNET、SSH

效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。举几个例子：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。

> HTTP：HyperText Transfer Protocol（超文本传输协议），默认端口80
> 
> FTP: File Transfer Protocol (文件传输协议), 默认端口(20用于传输数据，21用于传输控制信息)
> 
> SMTP: Simple Mail Transfer Protocol (简单邮件传输协议) ,默认端口25
> 
> TELNET: Teletype over the Network (网络电传), 默认端口23
>  
> SSH：Secure Shell（安全外壳协议），默认端口 22

- 基于UDP的应用层协议：DNS、TFTP、SNMP

效率要求相对高，对准确性要求相对低的场景。举几个例子：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）

> DNS : Domain Name Service (域名服务),默认端口 53
>
> TFTP: Trivial File Transfer Protocol (简单文件传输协议)，默认端口69
>
> SNMP：Simple Network Management Protocol（简单网络管理协议），通过UDP端口161接收，只有Trap信息采用UDP端口162。


# 7. TCP沾包/拆包

- 问题
TCP是面向字节流的（UDP基于报文），“流” 意味着TCP所传输的数据是没有边界的。TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。

- 原因

> 要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包；
>
> 接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包；
> 
> 要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包；（放数据的速度 > 应用层拿数据速度）
>
> 待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。即TCP报文长度-TCP头部长度>MSS。

- 解决：
> 1. 发送端将每个数据包封装为固定长度。
> 
> 2. 包头加上包体长度。包头是定长的4个字节，说明了包体的长度。接收方先接收包头长度，依据包头长度来接收包体。
> 
> 3. 在数据包之间设置边界，如添加特殊符号\r\n标记。FTP协议正是这么做的。但问题在于如果数据正文中也含有\r\n，则会误判为消息的边界。
> 
> 4. 使用更加复杂的应用层协议。

- 为什么等缓冲区满了才发送?

缓冲区的优势以文件流的写入为例，如果我们不使用缓冲区，每次写操作CPU都会和低速存储设备也就是磁盘进行交互，那么整个写入文件的速度就会受制于低速的存储设备（磁盘）。但如果使用缓冲区的话，每次写操作会先将数据保存在高速缓冲区内存上，当缓冲区的数据到达某个阈值之后，再将文件一次性写入到磁盘上。因为内存的写入速度远远大于磁盘的写入速度，所以当有了缓冲区之后，文件的写入速度就被大大提升了。

# 8. TCP是如何确保可靠性

- TCP的连接是基于三次握手，而断开则是基于四次挥手。确保连接和断开的可靠性。
- TCP的可靠性，还体现在有状态;TCP会记录哪些数据发送了，哪些数据被接收了，哪些没有被接受，并且保证数据包按序到达，保证数据传输不出差错。
- TCP的可靠性，还体现在可控制。它有数据包校验、ACK应答、超时重传(发送方)、失序数据重传（接收方）、丢弃重复数据、流量控制（滑动窗口）和拥塞控制等机制。

# 9. TCP滑动窗口机制

TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。 TCP会话的双方都各自维护一个发送窗口和一个接收窗口。接收窗口大小取决于应用、系统、硬件的限制。发送窗口则取决于对端通告的接收窗口。接收方发送的确认报文中的window字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将接收方的确认报文window字段设置为 0，则发送方不能发送数据。

![image](https://user-images.githubusercontent.com/72682213/189038407-1ec95555-2d01-40ee-b14e-c52ca02876c0.png)


TCP头包含window字段，16bit位，它代表的是窗口的字节容量，最大为65535。这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。接收窗口的大小是约等于发送窗口的大小。

# 10. 拥塞控制

防止过多的数据注入到网络中。 几种拥塞控制方法：慢开始( slow-start )、拥塞避免( congestion avoidance )、快重传( fast retransmit )和快恢复( fast recovery )。

![image](https://user-images.githubusercontent.com/72682213/189038437-af863964-c723-4013-92dc-7a82dc669735.png)

- 慢开始

> 把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。每经过一个传输轮次，拥塞窗口 cwnd 就加倍。 为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量。
>
> 当 cwnd < ssthresh 时，使用慢开始算法。
>
> 当 cwnd > ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。
>
> 当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。

- 拥塞避免

> 让拥塞窗口cwnd缓慢地增大，每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长。
>
> 无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半（但不能小于2）。
> 
> 然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。

- 快重传

有时个别报文段会在网络中丢失，但实际上网络并未发生拥塞。如果发送方迟迟收不到确认，就会产生超时，就会误认为网络发生了拥塞。这就导致发送方错误地启动慢开始，把拥塞窗口cwnd又设置为1，因而降低了传输效率。

快重传算法可以避免这个问题。快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认，使发送方及早知道有报文段没有到达对方。

发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待重传计时器到期。由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。

- 快恢复

当发送方连续收到三个重复确认，就会把慢开始门限ssthresh减半，接着把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。

在采用快恢复算法时，慢开始算法只是在TCP连接建立时和网络出现超时时才使用。 采用这样的拥塞控制方法使得TCP的性能有明显的改进。

# 11. HTTP协议







# 2.为什么需要三次握手？两次不行？
 



# 3. 为什么需要四次挥手？三次不行？
 









# 2. TCP协议如何保证可靠传输

可靠传输有如下两个特点：

> a.传输信道无差错,保证传输数据正确；
> 
> b.不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据（流量控制）。

- （1）采用三次握手来建立TCP连接，四次挥手来释放TCP连接，从而保证建立的传输信道是可靠的。
- （2）TCP采用了连续ARQ协议（回退N，Go-back-N；超时自动重传）来保证数据传输的正确性，使用滑动窗口协议保证接收方能够及时处理所接收到的数据，进行流量控制。


数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时 TCP 发送数据端超时后会重发数据。

对失序数据包重排序：既然 TCP 报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序，因此 TCP 报文段的到达也可能会失序。TCP 将对失序数据进行重新排序，然后才交给应用层；
丢弃重复数据：对于重复数据，能够丢弃重复数据。

应答机制：当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒。

超时重发：当TCP发出一个段后，启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。

- （3）最后，TCP使用慢开始、拥塞避免、快重传和快恢复来进行拥塞控制，避免网络拥塞。


TCP是面向连接的、可靠的、传输层通信协议。可靠体现在：
有状态：TCP会确认发送了哪些报文，接收方受到了哪些报文，哪些没有收到，保证数据包按序到达，不允许有差错。
可控制：如果出现丢包或者网络状况不佳，则会跳转自己的行为，减少发送的速度或者重发，所以上面能保证数据包的有效传输。




算机网络：HTTP，HTTP请求报文格式、GET和POST、TCP三次握手、TCP和UDP
作者：zhusers
链接：https://www.nowcoder.com/discuss/1030526?type=0&channel=-1&source_id=discuss_terminal_discuss_hot_nctrack
来源：牛客网

1、TCP、UDP可以绑定相同的端口吗？多个TCP进程可以绑定同一个端口吗？
2、什么情况下，可以重新利用这个端口？
3、介绍一下time_wait是一个什么状态，为什么需要这个状态，有什么作用？
4、time_wait状态会带来什么副作用吗？
5、同步IO和异步IO介绍一下？
