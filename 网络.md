# 1 TCP沾包

- 原因：
&ensp;   
TCP是一个基于字节流的传输服务（UDP基于报文的），“流” 意味着TCP所传输的数据是没有边界的。所以可能会出现两个数据包粘在一起的情况。

&ensp;   
当发送的数据包过于的小时，那么TCP协议默认的会启用Nagle算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。
&ensp;   
接收方采用TCP协议接收数据时的过程是这样的：数据到接收方，从网络模型的下方传递至传输层，传输层的TCP协议处理是将其放置接收缓冲区，
然后由应用层来主动获取（C 语言用 recv、read 等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的
数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 > 应用层拿数据速度）

- 解决：
> 发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。
> 
> 包头加上包体长度。包头是定长的4个字节，说明了包体的长度。接收方先接收包头长度，依据包头长度来接收包体。
> 
> 在数据包之间设置边界，如添加特殊符号\r\n标记。FTP协议正是这么做的。但问题在于如果数据正文中也含有\r\n，则会误判为消息的边界。
> 
> 使用更加复杂的应用层协议。
