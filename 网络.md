# 1. 网络编程

创建socket
```cpp
socket()
```
 
- 忽略SIGPIPE信号

> 当通信一端断开连接时，系统会发送SIGPIPE信号，默认是关闭进程，程序应当在检测到对方断开连接时做出相应处理，而不是任由系统关闭程序。

- 打开SO_REUSEADDR选项

> socket服务端一定要打开这个选项，否则bind()可能不成功：Address already in use。

```cpp
char opt = 1; usigned int len = sizeof(opt);
setsockopt(listenfd,SOL_SOCKET,SO_REUSEADDR,&opt,len); 
```

## 长连接

> 在同一网段内部，网络设备不会断开空闲的链接。
> 在不同网段之间网络设备会断开连接，超时时间1-5分钟。
> 网络服务程序心跳的超时时间一般设置在50-120秒之间。


# 2. 网络分层结构

- 五层模型：应用层、传输层、网络层、数据链路层、物理层。

> 应用层：为应用程序提供交互服务。在互联网中的应用层协议很多，如域名系统DNS、HTTP协议、SMTP协议等。
> 
> 传输层：负责向两台主机进程之间的通信提供数据传输服务。传输层的协议主要有传输控制协议TCP和用户数据协议UDP。
> 
> 网络层：选择合适的路由和交换结点，确保数据及时传送。主要包括IP协议。
> 
> 数据链路层：在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。
> 
> 物理层：实现相邻节点间比特流的透明传输，尽可能屏蔽传输介质和物理设备的差异。

# 3. 三次握手，两次？

![image](https://user-images.githubusercontent.com/72682213/189035299-66f5e0d5-e1b6-4732-8b90-5736a3923a36.png)

- 第一次握手：客户端向服务端发起建立连接请求，客户端会随机生成一个起始序列号x，客户端向服务端发送的字段中包含标志位SYN=1，序列号seq=x。第一次握手前客户端的状态为CLOSE，第一次握手后客户端的状态为SYN-SENT。此时服务端的状态为LISTEN。

- 第二次握手：服务端在收到客户端发来的报文后，会随机生成一个服务端的起始序列号y，然后给客户端回复一段报文，其中包括标志位SYN=1，ACK=1，序列号seq=y，确认号ack=x+1。第二次握手前服务端的状态为LISTEN，第二次握手后服务端的状态为SYN-RCVD，此时客户端的状态为SYN-SENT。（其中SYN=1表示要和客户端建立一个连接，ACK=1表示确认序号有效）

- 第三次握手：客户端收到服务端发来的报文后，会再向服务端发送报文，其中包含标志位ACK=1，序列号seq=x+1，确认号ack=y+1。第三次握手前客户端的状态为SYN-SENT，第三次握手后客户端和服务端的状态都为ESTABLISHED。此时连接建立完成。

> 第三次握手主要为了防止已失效的连接请求报文段突然又传输到了服务端，导致产生问题。
>
> 比如客户端A发出连接请求，可能因为网络阻塞原因，A没有收到确认报文，于是A再重传一次连接请求。
>
> 连接成功，等待数据传输完毕后，就释放了连接。
>
> 然后A发出的第一个连接请求等到连接释放以后的某个时间才到达服务端B，此时B误认为A又发出一次新的连接请求，于是就向A发出确认报文段。
>
> 如果不采用三次握手，只要B发出确认，就建立新的连接了，此时A不会响应B的确认且不发送数据，则B一直等待A发送数据，浪费资源。

# 4. 四次挥手

![image](https://user-images.githubusercontent.com/72682213/189035597-5876ac39-0afd-4185-b9c9-cb7bbd508aa8.png)

- A的应用进程先向其TCP发出连接释放报文段（FIN=1，seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN-WAIT-1（终止等待1）状态，等待B的确认。

- B收到连接释放报文段后即发出确认报文段（ACK=1，ack=u+1，seq=v），B进入CLOSE-WAIT（关闭等待）状态，此时的TCP处于半关闭状态，A到B的连接释放。

- A收到B的确认后，进入FIN-WAIT-2（终止等待2）状态，等待B发出的连接释放报文段。

- B发送完数据，就会发出连接释放报文段（FIN=1，ACK=1，seq=w，ack=u+1），B进入LAST-ACK（最后确认）状态，等待A的确认。

- A收到B的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），A进入TIME-WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL（最大报文段生存时间）后，A才进入CLOSED状态。B收到A发出的确认报文段后关闭连接，若没收到A发出的确认报文段，B就会重传连接释放报文段。


- 第四次挥手为什么要等待2MSL？

保证A发送的最后一个ACK报文段能够到达B。这个ACK报文段有可能丢失，B收不到这个确认报文，就会超时重传连接释放报文段，然后A可以在2MSL时间内收到这个重传的连接释放报文段，接着A重传一次确认，重新启动2MSL计时器，最后A和B都进入到CLOSED状态，若A在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到B重传的连接释放报文段，所以不会再发送一次确认报文段，B就无法正常进入到CLOSED状态。

防止已失效的连接请求报文段出现在本连接中。A在发送完最后一个ACK报文段后，再经过2MSL，就可以使这个连接所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现旧的连接请求报文段。

- 为什么是四次挥手

因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。但是在关闭连接时，当Server端收到Client端发出的连接释放报文时，很可能并不会立即关闭SOCKET，所以Server端先回复一个ACK报文，告诉Client端我收到你的连接释放报文了。只有等到Server端所有的报文都发送完了，这时Server端才能发送连接释放报文，之后两边才会真正的断开连接。故需要四次挥手。

# 4. TCP特点

| TCP | UDP |
|-|-|
|面向连接的运输层协议                       | 无连接的，即发送数据之前不需要建立连接|
|可靠交付的服务                                |不保证可靠交付|
|面向字节流,把数据看成一连串无结构的字节流   |面向报文|
|每一条TCP连接只能是点到点的                |支持一对一、一对多、多对一和多对多的通信方式|
|有拥塞控制|  没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如实时视频会议等）    |
|首部20个字节|首部8个字节|
|全双工通信|          |


# 5. TCP报文首部

![image](https://user-images.githubusercontent.com/72682213/189035937-0ea0caac-bc00-4915-8c0d-85b2542b17f5.png)

16位端口号：源端口号，主机该报文段是来自哪里；目标端口号，要传给哪个上层协议或应用程序

32位序号：一次TCP通信（从TCP连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。

32位确认号：用作对另一方发送的tcp报文段的响应。其值是收到的TCP报文段的序号值加1。

4位头部长度：表示tcp头部有多少个32bit字（4字节）。因为4位最大能标识15，所以TCP头部最长是60字节。

6位标志位：URG(紧急指针是否有效)，ACk（表示确认号是否有效），PSH（缓冲区尚未填满），RST（表示要求对方重新建立连接），SYN（建立连接消息标志接），FIN（表示告知对方本端要关闭连接了）

16位窗口大小：是TCP流量控制的一个手段。这里说的窗口，指的是接收通告窗口。它告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。

16位校验和：由发送端填充，接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。注意，这个校验不仅包括TCP头部，也包括数据部分。这也是TCP可靠传输的一个重要保障。

16位紧急指针：一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP的紧急指针是发送端向接收端发送紧急数据的方法。

# 6. TCP和UDP区别



# 3. TCP沾包

- 原因：

TCP是一个基于字节流的传输服务（UDP基于报文的），“流” 意味着TCP所传输的数据是没有边界的。所以可能会出现两个数据包粘在一起的情况。 

当发送的数据包过小时（小于套接字缓冲区的大小），TCP协议默认的会启用Nagle算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。

接收方采用TCP协议接收数据时的过程是这样的：数据到接收方，从网络模型的下方传递至传输层，传输层的TCP协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C语言用recv、read等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 > 应用层拿数据速度）

- 解决：
> 1. 发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。
> 
> 2. 包头加上包体长度。包头是定长的4个字节，说明了包体的长度。接收方先接收包头长度，依据包头长度来接收包体。
> 
> 3. 在数据包之间设置边界，如添加特殊符号\r\n标记。FTP协议正是这么做的。但问题在于如果数据正文中也含有\r\n，则会误判为消息的边界。
> 
> 4. 使用更加复杂的应用层协议。


- 为什么等缓冲区满了才发送?

缓冲区的优势以文件流的写入为例，如果我们不使用缓冲区，每次写操作CPU都会和低速存储设备也就是磁盘进行交互，那么整个写入文件的速度就会受制于低速的存储设备（磁盘）。但如果使用缓冲区的话，每次写操作会先将数据保存在高速缓冲区内存上，当缓冲区的数据到达某个阈值之后，再将文件一次性写入到磁盘上。因为内存的写入速度远远大于磁盘的写入速度，所以当有了缓冲区之后，文件的写入速度就被大大提升了。


# 2.为什么需要三次握手？两次不行？
 
三次握手过程：

> 1、第一次握手：客户端给服务器发送一个SYN报文，说明客户端请求建立连接。
> 
> 2、第二次握手：服务器收到SYN，回复SYN（同步标志位）+ACK（确认标志位）报文，同意建立连接。
> 
> 3、第三次握手：客户端收到SYN+ACK报文之后，回复ACK给服务端（表示客户端收到了服务端发的同意报文）。
> 
> 4、服务器收到ACK报文之后，三次握手建立完成。

原因：

> 1、因为信道不可靠，而 TCP 想在不可靠信道上建立可靠地传输，那么三次通信是理论上的最小值。（而 UDP 则不需建立可靠传输，因此 UDP 不需要三次握手。）
> 
> 2、双方都需要确认对方收到了自己发送的序列号，确认过程最少要进行三次通信。
> 
> 3、为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。


# 3. 为什么需要四次挥手？三次不行？
 









# 2. TCP协议如何保证可靠传输

可靠传输有如下两个特点：

> a.传输信道无差错,保证传输数据正确；
> 
> b.不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据（流量控制）。

- （1）采用三次握手来建立TCP连接，四次挥手来释放TCP连接，从而保证建立的传输信道是可靠的。
- （2）TCP采用了连续ARQ协议（回退N，Go-back-N；超时自动重传）来保证数据传输的正确性，使用滑动窗口协议保证接收方能够及时处理所接收到的数据，进行流量控制。


数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时 TCP 发送数据端超时后会重发数据。

对失序数据包重排序：既然 TCP 报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序，因此 TCP 报文段的到达也可能会失序。TCP 将对失序数据进行重新排序，然后才交给应用层；
丢弃重复数据：对于重复数据，能够丢弃重复数据。

应答机制：当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒。

超时重发：当TCP发出一个段后，启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。

- （3）最后，TCP使用慢开始、拥塞避免、快重传和快恢复来进行拥塞控制，避免网络拥塞。


TCP是面向连接的、可靠的、传输层通信协议。可靠体现在：
有状态：TCP会确认发送了哪些报文，接收方受到了哪些报文，哪些没有收到，保证数据包按序到达，不允许有差错。
可控制：如果出现丢包或者网络状况不佳，则会跳转自己的行为，减少发送的速度或者重发，所以上面能保证数据包的有效传输。




算机网络：HTTP，HTTP请求报文格式、GET和POST、TCP三次握手、TCP和UDP
作者：zhusers
链接：https://www.nowcoder.com/discuss/1030526?type=0&channel=-1&source_id=discuss_terminal_discuss_hot_nctrack
来源：牛客网

1、TCP、UDP可以绑定相同的端口吗？多个TCP进程可以绑定同一个端口吗？
2、什么情况下，可以重新利用这个端口？
3、介绍一下time_wait是一个什么状态，为什么需要这个状态，有什么作用？
4、time_wait状态会带来什么副作用吗？
5、同步IO和异步IO介绍一下？
