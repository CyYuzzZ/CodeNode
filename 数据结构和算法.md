# 1 数据结构问题
## 时间复杂度、空间复杂度

## 线性表
### 顺序表
优点：可随机存储，存储密度高。
缺点：要求连续的内存空间，扩容不方便，插入和删除元素需要移动其他的元素。

### 链表
优点：不要求连续的内存空间，扩容很方便，插入和删除元素不需要移动其他的元素。
缺点：不能随机存储，指针需要消耗空间。



数组和链表的区别？

链表连续存储的使用场景？

栈和队列区别


## 二叉树

二叉树的遍历

## 哈希表

# 2 STL
## 2.1 vector
- 成员函数

|成员函数|功能|
|-|-|
| size()      | 返回实际元素个数|
| erase()     | 移出一个元素或一段元素(指定范围)   |

```cpp
begin()	                     // 返回指向容器中第一个元素的迭代器。
end()	                     // 返回指向容器最后一个元素所在位置后一个位置的迭代器
empty()	                     // 无元素返回true；反之返回false
push_back()	             // 在序列的尾部添加一个元素。
pop_back()	             // 移出序列尾部的元素。

insert()	             // 在指定的位置插入一个或多个元素
//不常用
rbegin()	                         返回指向最后一个元素的迭代器。
rend()	                         返回指向第一个元素所在位置前一个位置的迭代器。
cbegin()	                      和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。
cend()	                        和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。
crbegin()	和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。
crend()	和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。
max_size()	返回元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。
resize()	改变实际元素的个数。
capacity()	返回当前容量。
reserve()	增加容器的容量。
shrink _to_fit()	将内存减少到等于当前元素实际所使用的大小。
operator[ ]	重载了 [ ] 运算符，可以向访问数组中元素那样，通过下标即可访问甚至修改 vector 容器中的元素。
at()	使用经过边界检查的索引访问元素。
front()	返回第一个元素的引用。
back()	返回最后一个元素的引用。
data()	返回指向容器中第一个元素的指针。
assign()	用新元素替换原有内容。
clear()	移出所有的元素，容器大小变为 0。
swap()	交换两个容器的所有元素。
emplace()	在指定的位置直接生成一个元素。
emplace_back()	在序列尾部生成一个元素。
```

## 2.2 array


## 2.3 list


## 2.4 deque 双端队列
双端队列：

当需要向序列两端频繁的添加或删除元素时，应首选 deque 容器。


## 2.5 stack 栈
栈：仅在表尾插入和删除的线性表，**先进后出**。

开口端称为栈顶。

- 创建
```cpp
// 1 创建一个不包含任何元素的 stack 适配器，并采用默认的 deque 基础容器
stack<int> values;     
// 2 第2个参数指定 vector、deque 和 list 3 个基础容器
stack<string, list<int>> values;   
// 3 用基础容器初始化stack
std::list<int> values {1, 2, 3};
std::stack<int,std::list<int>> my_stack (values);
// 4 用一个stack初始化另一个stack（存储类型相同，基础容器相同）
```

- 成员函数
```cpp
empty()	             // 没有元素返回true；反之返回false。
size()	             // 返回stack栈中存储元素的个数。
top()	               // 返回一个栈顶元素的引用，类型为 T&。如果栈为空，程序会报错。
push(const T& val)	 // 先复制val，再将val 副本压入栈顶。这是通过调用底层容器的 push_back() 函数完成的。
push(T&& obj)	       // 以移动元素的方式将其压入栈顶。这是通过调用底层容器的有右值引用参数的 push_back() 函数完成的。
pop()	               // 弹出栈顶元素。
emplace(arg...)	     // arg... 可以是一个参数，也可以是多个参数，但它们都只用于构造一个对象，并在栈顶直接生成该对象，作为新的栈顶元素。
swap(stack<T> & other_stack)  	// 将两个stack的元素互换，进行互换的2个stack存储的元素类型及基础容器类型都必须相同。
```

## 2.6 queue 队列
队列：先进先出

从最低端加入元素，从最顶端取得元素，不允许有遍历行为。


## 2.7 有序容器

- **创建**

```cpp
set<string> myset;                 // 创建set
multiset<string> mymultiset;      // 创建multiset
```

- **成员函数**

multiset和set成员函数一样。

|成员函数|功能|
|-|-|
|empty()     | 若容器为空，则返回 true；否则 false  |
|count(val)  | 查找值为val的元素的个数，并返回。set的返回值最大为1|
|insert()    | 向 set 容器中插入元素 |

```cpp
begin()	返回指向容器中第一个（注意，是已排好序的第一个）元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。
end()	返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。
rbegin()	返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。
rend()	返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。
cbegin()	和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。
cend()	和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。
crbegin()	和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。
crend()	和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。
find(val)	在 set 容器中查找值为 val 的元素，如果成功找到，则返回指向该元素的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。
lower_bound(val)	返回一个指向当前 set 容器中第一个大于或等于 val 的元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。
upper_bound(val)	返回一个指向当前 set 容器中第一个大于 val 的元素的迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。
equal_range(val)	该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的值为 val 的元素（set 容器中各个元素是唯一的，因此该范围最多包含一个元素）。
	
size()	返回当前 set 容器中存有元素的个数。
max_size()	返回 set 容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同。

erase()	删除 set 容器中存储的元素。
swap()	交换 2 个 set 容器中存储的所有元素。这意味着，操作的 2 个 set 容器的类型必须相同。
clear()	清空 set 容器中所有的元素，即令 set 容器的 size() 为 0。
emplace()	在当前 set 容器中的指定位置直接构造新元素。其效果和 insert() 一样，但效率更高。
emplace_hint()	在本质上和 emplace() 在 set 容器中构造新元素的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示新元素生成位置的迭代器，并作为该方法的第一个参数。

```


## 2.8 无序容器
| 无序容器  |  功能|
|------------|-|
| unordered_map      | 存储键值对 <key, value> 类型的元素，其中各个键值对键的值不允许重复，且该容器中存储的键值对是无序的。|
| unordered_multimap | 和 unordered_map 唯一的区别在于，该容器允许存储多个键相同的键值对。|
| unordered_set	     | 不再以键值对的形式存储数据，而是直接存储数据元素本身（当然也可以理解为，该容器存储的全部都是键 key 和值 value 相等的键值对，正因为它们相等，因此只存储 value 即可）。另外，该容器存储的元素不能重复，且容器内部存储的元素也是无序的。|
| unordered_multiset	|和 unordered_set 唯一的区别在于，该容器允许存储值相同的元素。|


- 创建 unordered_map
```cpp
unordered_map<string, string> umap;

```

- 成员函数

|函数|功能|
|-|-|
|operator[key]	|  该模板类中重载了[]运算符，可以向访问数组中元素那样，只要给定某个键值对的键key，就可以获取该键对应的值。如果当前容器中没有以key为键的键值对，则其会使用该键向当前容器中插入一个新键值对。|
|  |    | 

```cpp
begin()	返回指向容器中第一个键值对的正向迭代器。
end() 	返回指向容器中最后一个键值对之后位置的正向迭代器。
cbegin()	和 begin() 功能相同，只不过在其基础上增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。
cend()	和 end() 功能相同，只不过在其基础上，增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。
empty()	若容器为空，则返回 true；否则 false。
size()	返回当前容器中存有键值对的个数。
max_size()	返回容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。
at(key)	返回容器中存储的键 key 对应的值，如果 key 不存在，则会抛出 out_of_range 异常。 
find(key)	查找以 key 为键的键值对，如果找到，则返回一个指向该键值对的正向迭代器；反之，则返回一个指向容器中最后一个键值对之后位置的迭代器（如果 end() 方法返回的迭代器）。
count(key)	在容器中查找以 key 键的键值对的个数。
equal_range(key)	返回一个 pair 对象，其包含 2 个迭代器，用于表明当前容器中键为 key 的键值对所在的范围。
emplace()	向容器中添加新键值对，效率比 insert() 方法高。
emplace_hint()	向容器中添加新键值对，效率比 insert() 方法高。
insert() 	向容器中添加新键值对。
erase()	删除指定键值对。
clear() 	清空容器，即删除容器中存储的所有键值对。
swap()	交换 2 个 unordered_map 容器存储的键值对，前提是必须保证这 2 个容器的类型完全相等。
bucket_count()	返回当前容器底层存储键值对时，使用桶（一个线性链表代表一个桶）的数量。
max_bucket_count()	返回当前系统中，unordered_map 容器底层最多可以使用多少桶。
bucket_size(n)	返回第 n 个桶中存储键值对的数量。
bucket(key)	返回以 key 为键的键值对所在桶的编号。
load_factor()	返回 unordered_map 容器中当前的负载因子。负载因子，指的是的当前容器中存储键值对的数量（size()）和使用桶数（bucket_count()）的比值，即 load_factor() = size() / bucket_count()。
max_load_factor()	返回或者设置当前 unordered_map 容器的负载因子。
rehash(n)	将当前容器底层使用桶的数量设置为 n。
reserve()	将存储桶的数量（也就是 bucket_count() 方法的返回值）设置为至少容纳count个元（不超过最大负载因子）所需的数量，并重新整理容器。
hash_function()	返回当前容器使用的哈希函数对象。
```







# 3 排序算法

## 3.0 复杂度比较

|  排序算法  |  平均时间复杂度  |  最坏时间复杂度  |  最好时间复杂度  |  空间复杂度  |  稳定性  |
|------------|-----------------|------------------|------------------|--------------|---------|
|  冒泡排序  | O(n²)          | O(n²)             | O(n)           | O(1)          | 稳定     |
|  选择排序  | O(n²)          | O(n²)             | O(n²)          | O(1)          | 不稳定   |
|  插入排序  | O(n²)          | O(n²)             | O(n²)          | O(1)          | 稳定     |
|  快速排序  | O(nlogn)       | O(n²)             | O(nlogn)       | O(nlogn)      | 不稳定   |
|  堆排序    | O(nlogn)       | O(nlogn)          | O(nlogn)       | O(1)          | 不稳定   |
|  希尔排序  | O(nlogn)       | O(nlogn)          | O(n)           | O(1)          | 不稳定   |
|  归并排序  | O(nlogn)       | O(nlogn)          | O(nlogn)       | O(n)          | 稳定     |
|  计数排序  | O(n+k)         | O(n+k)            | O(n+k)         | O(n+k)        | 稳定     |
|  基数排序  | O(N* M)        | O(N* M)           | O(N* M)        | O(M)          | 稳定     |


## 3.1 冒泡排序

两个for循环

优化：判断外层一次for循环有没有交换数据，没有则直接结束。

## 3.2 选择排序

从头到尾扫描序列，找出最小的一个元素，和第一个元素交换，接着从剩下的元素中继续这种选择和交换方式，最终得到一个有序序列。

## 3.3 插入排序

## 3.4 希尔排序

## 3.5 快速排序

## 3.6 归并排序

## 3.7 堆排序

## 3.8 计数排序

## 3.9 桶排序

## 3.10 基数排序


# 4 其他算法
## 4.1 递归
### 4.1.1 递归的复杂度
递归函数嵌套的调用自己，函数的参数和局部变量占用的内存空间在递去的过程中会持续增长，在归来的时候才逐层释放。当递归的深度达到一定量级，可能会造成栈内存空间不足的情况。


# 5 算法相关问题

快速排序和冒泡时间复杂度，两种算法稳定性分析；

快排的原理


# 6 剑指offer

## 6.1 链表
### 6 从尾到头打印链表 √          
### 18 删除链表的结点 √
### 22 链表中（删除）倒数第k个节点 √
### 24 反转链表 √
### 25 合并两个排序链表 √
### 35 复杂链表的复制 √
### 52 两个链表的第一个公共节点 √
### 36 二叉搜索树与双向链表



## 1 数组中重复的数字
## 2 二维数组中的查找

## 数据结构
链表：








字符串的逆序



猴子爬台阶，可以一次走一个台阶或三个台阶，问n个台阶有多少种走法

奥运会奖牌数排序，按照金-银-铜-国家首字母优先级排序

场景题？兔子每隔三个月生一对双胞胎，算法实现？


11、场景题？假设饮料有1块的，2块的，5块的，我有n块钱，我能买多少饮料，算法实现？
