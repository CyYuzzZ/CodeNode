# 1 数据结构
## 1.1 数组
## 1.2 队列
双端队列
## 1.3 链表
## 1.4 栈




## 1.5 二叉树
- 概念

> 度为m的树，至少一个节点的度为m，树至少有m+1个结点
> 
> m叉树，全部节点的度≤m，可能全部都小于m，树可以为空。

> 满二叉树：高度为h，有2^h-1个结点的二叉树。（最下层满结点）
> 
> 完全二叉树：每一层都是满的，最下面一层结点集中在最左边
> 
> 二叉排序树（二叉查找树）：树上任意结点如果存在左子树和右子树，则左子树上所有结点元素的值都小于该结点，右子树都大于。

- 完全二叉树

> 对于下标为i的结点，左子结点下标为2i+1，右子结点下标为2i+2，双亲结点下标为(i-1)/2向下取整。下标从0开始。
	
- 存储结构

> 顺序存储的方法存普通二叉树容易造成空间浪费，比较适合完全二叉树
> 
> 链式存储

- 二叉树的遍历
```cpp
// 层次遍历
vector<vector<int>> levelOrder(TreeNode* root) {
    vector<vector<int>> ret;
    if(!root) return ret;
    queue<TreeNode*> q;
    q.push(root);
    while(!q.empty())
    {
        int curlevel = q.size();
        ret.push_back(vector <int> ());          
        for(int i=1;i<=curlevel;i++)
        {
            TreeNode *node = q.front();
            q.pop();
            ret.back().push_back(node->val);
            if(node->left) q.push(node->left);
            if(node->right) q.push(node->right);
        }   
    }
    return ret;
}

// 前序遍历   根、左子树、右子树
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;
        if(root == nullptr) return res;
        stack<TreeNode*> s;
        while(!s.empty() || root != nullptr){
            while(root!=nullptr){
                res.push_back(root->val);
                s.push(root);
                root = root->left;
            }
            root = s.top();
            s.pop();
            root = root->right;
        }
        return res;
    }
    
// 中序遍历   左子树、根、右子树
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        if(root == nullptr) return res;
        stack<TreeNode*> s;
        while(!s.empty() || root){
            while(root){
                s.push(root);
                root = root->left;
            }
            root = s.top();
            s.pop();
            res.push_back(root->val);
            root = root->right;
        }
        return res;
    }

// 后序遍历   左子树、右子树、根
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> s;
        TreeNode* prev = nullptr;
        while(root!=nullptr || !s.empty()){
            while(root){
                s.push(root);
                root = root->left;
            }
            root = s.top();
            s.pop();
            if(root->right == nullptr || root->right == prev){
                res.push_back(root->val);
                prev = root;
                root = nullptr;
            }else{
                s.push(root);
                root = root->right;
            }
        }
        return res;
    }

// 递归
void preorder(TreeNode* root,vector<int> &ret){
    if(!root) return ;
    ret.push_back(root->val);
    preorder(root->left,ret);
    preorder(root->right,ret);
}
vector<int> preorderTraversal(TreeNode* root) {
    vector<int> ret;
    preorder(root,ret);
    return ret;
}
```

- 遍历序列构造二叉树

> 前序+中序
> 
> 后序+中序
> 
> 层次+中序

- 线索二叉树

> 如果结点没有左子结点，则将左指针指向遍历序列中的前驱结点。
> 
> 如果结点没有右子结点，则将右指针指向遍历序列中的后继结点。








## 红黑树

## B树
## 1.6 哈希表
## 1.7 堆
## 1.8 图



## 线性表
### 顺序表
优点：可随机存储，存储密度高。
缺点：要求连续的内存空间，扩容不方便，插入和删除元素需要移动其他的元素。

### 链表
优点：不要求连续的内存空间，扩容很方便，插入和删除元素不需要移动其他的元素。
缺点：不能随机存储，指针需要消耗空间。


# 2 算法

## 2.1 排序算法

### 00 复杂度比较

|  排序算法  |  平均时间复杂度  |  最坏时间复杂度  |  最好时间复杂度  |  空间复杂度  |  稳定性  |
|------------|-----------------|------------------|------------------|--------------|---------|
|  冒泡排序  | O(n²)          | O(n²)             | O(n)           | O(1)          | 稳定     |
|  选择排序  | O(n²)          | O(n²)             | O(n²)          | O(1)          | 不稳定   |
|  插入排序  | O(n²)          | O(n²)             | O(n)           | O(1)          | 稳定     |
|  希尔排序  | O(nlogn)       | O(nlogn)          | O(n)           | O(1)          | 不稳定   |
|  快速排序  | O(nlogn)       | O(n²)             | O(nlogn)       | O(nlogn)      | 不稳定   |
|  归并排序  | O(nlogn)       | O(nlogn)          | O(nlogn)       | O(n)          | 稳定     |
|  堆排序    | O(nlogn)       | O(nlogn)          | O(nlogn)       | O(1)          | 不稳定   |
|  计数排序  | O(n+k)         | O(n+k)            | O(n+k)         | O(n+k)        | 稳定     |
|  桶排序    | O(n+k)         | O(n²)             | O(n)           | O(n+k)        | 稳定     |
|  基数排序  | O(N* M)        | O(N* M)           | O(N* M)        | O(N+M)        | 稳定     |


### 01 冒泡排序

两个for循环

优化：判断外层一次for循环有没有交换数据，没有则直接结束。

### 02 选择排序

从头到尾扫描序列，找出最小的一个元素，和第一个元素交换，接着从剩下的元素中继续这种选择和交换方式，最终得到一个有序序列。

优化：选择排序一次循环把最大值最小值都选出来，分别放在两端。如果最大值在最左边，交换最小之后，最大值在之前的最小值位置上。

### 03 插入排序

原理：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）

插入排序的缺点：

> （1）寻找插入位置
> 
> （2）移动元素

优化方案：

> （1）对已排好序的序列，采用二分查找方法
> 
> （2）携带多个元素
> 
> （3）数据链表化
> 
> （4）希尔排序

### 04 希尔排序

希尔排序是插入排序的一种，是针对直接插入排序的改进

希尔排序的思想是化远为近：

> （1）查找次数减少
> 
> （2）移动元素的次数减少。

希尔排序的基本思想：把待排序的数列分为多个组，然后再对每个组进行插入排序，先让数列整体大致有序，然后多次调整分组方式，师叔祖更加有序，最后在使用一次插入排序，整个数列将全部有序。

选择增量 gap=length/2，缩小增量以 gap = gap/2 的方式。

### 05 快速排序⭐

- 基本思想

> 先从数列中取出元素作为基准数
> 
> 扫描数列，将比基准数小的元素全部放在它的左边，大于或等于基准数的元素全部放到它的右边，得到左右两个区间
> 
> 在对左右区间重复第二步，直到区间元素少于两个元素

- 实现

```cpp

```

- 优化

> 采用更合理的基准数，减少递归深度。从数列中选取多个数，取中间数
> 
> 结合插入排序，区间在10个以内采用插入排序

### 06 归并排序⭐

将已经有序的子数列合并，得到另一个有序的数列。

用递归或循环实现归并排序

### 07 堆排序⭐

堆排序是利用堆这种数据结构而设计的排序算法。

堆具备以下特点：

> 完全二叉树（每一层都是满的，最下面一层结点集中在最左边）。
> 
> 二叉树每个结点的值都大于或等于其左右子树结点的值，称为大顶堆；每个结点小于或等于其左右子节点时，称为小顶堆。
> 
> N[i]的左节点：N[2i+1]
> 
> N[i]的右节点：N[2i+2]
> 
> N[i]的父节点：N[(i-1)/2]

### 08 计数排序

- 计数排序的条件

> 排序的元素必须是整数
> 
> 排序元素的取值要在一定范围内，并且比较集中

- 优化

> 数组长度定义为 max-min-+1 。

### 09 桶排序 ⭐

- 原理

> 假设输入数据服从均匀分布，将数据分到有限数量的桶里，
> 
> 然后再对每个桶分别排序，
> 
> 最后把全部桶的数据合并。

桶排序的时间复杂度取决于对桶之间数据进行排序的时间复杂度，因为其他部分的时间复杂度都是O(n)。很显然，桶划分的越小，桶里的数据就越少，排序所用时间也会越少，但相应空间消耗会增大。

- 桶思想

> 实际开发中，大部分数据是均匀的，或者在设计的时候可以让他均匀，或者说可以转换为均匀的分布。

### 10 基数排序

基数排序（Radix sort）是桶排序的扩展。

- 思想

> 将整数按位数切割成不同的数字，然后按每个位数分别比较。从低位排到高位，桶先进先出（队列queue）。
> 基数排序可以理解为按关键字排序，如个位十位百位，日期的年月日

```cpp
int main()
{
    int arr[] = {144,203,738,905,347,215,836,26,527,602,946,504,219,750,848};
    int len = sizeof(arr)/sizeof(int), max=0;
    int ret[len]; 
    for(int i=0;i<len;i++){
        if(arr[i]>max) max = arr[i];  // 获取最大值
    }       
    for(int exp=1;max/exp>0;exp=exp*10){
    int count[10] = {0};
        for(int i=0;i<len;i++){
            count[(arr[i]/exp)%10]++;    // 统计个位数/十位数出现次数
        }
        for(int i=1;i<10;i++){
            count[i] = count[i]+count[i-1]; 
        }
        for(int i=len-1;i>=0;i--)
        {   
            int ind = (arr[i]/exp)%10;
            ret[count[ind]-1] = arr[i];
            count[ind]--;
        }
    }
}
```


## 2.2 查找算法

### 2.2.1 顺序查找

从头到尾遍历

### 2.2.2 二分查找

二分查找又称折半查找，前提条件：1.必须采用顺序存储结构 2.必须按关键字大小有序排列。


### 2.2.3 插值查找

基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。它是二分查找的改进版。


### 2.2.4 斐波那契查找
 
在是二分查找的一种提升算法，通过运用黄金比例的概念在数列中选择查找点进行查找，提高查找效率。注意同时属于一种有序查找算法

### 2.2.5 二叉树查找

二叉查找树是先对待查找的数据进行生成树，确保树的左分支的值小于右分支的值，然后在就行和每个节点的父节点比较大小，查找最适合的范围。

前提条件要首先创建树。 

二叉查找树或者是一棵空树，特点如下：

　　1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；

　　2）若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；

　　3）任意节点的左、右子树也分别为二叉查找树。

### 2.2.6 分块查找

它是顺序查找的一种改进方法。将 n 个数据元素 "按块有序" 划分为 m 块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须"按块有序"；第 i 块中的每个元素一定比第 i-1 块中的任意元素大（小）。

1） 先选取各块中的最大关键字构成一个索引表；

2） 查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；然后，在已确定的块中用顺


### 2.2.7 哈希查找

如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。

注意：

1）用给定的哈希函数构造哈希表；

2）根据选择的冲突处理方法解决地址冲突；

常见的解决冲突的方法：拉链法和线性探测法。

3）在哈希表的基础上执行哈希查找。

## 2.3 KMP算法



## 2.3 递归

递归函数嵌套的调用自己，函数的参数和局部变量占用的内存空间在递去的过程中会持续增长，在归来的时候才逐层释放。当递归的深度达到一定量级，可能会造成栈内存空间不足的情况，栈溢出（Core dump）。

函数的调用有时间和空间的开销，一个程序中同时调用的函数个数是有限的。

一般当循环方法容易实现时，应当避免递归。

- 分而治之

> 把一个问题分解成子问题

## 2.4 动态规划

# 3 算法题目

## 3.1 基本计算器2 


# 4 算法相关问题


# 6 剑指offer

## 6.1 链表 8
### 06 从尾到头打印链表 √          
### 18 删除链表的结点 √
### 22 链表中（删除）倒数第k个节点 √
### 24 反转链表 √
### 25 合并两个排序链表 √
### 35 复杂链表的复制 √
### 52 两个链表的第一个公共节点 √
### 36 二叉搜索树与双向链表


## 6.2 数组 22
### 03 数组中重复的数字 √
### 04 二维数组中的查找 √
### 07 重建二叉树
### 11 旋转数组的最小数字
### 12 矩阵中的路径
### 17 打印从1到最大的n位数
### 21 调整数组顺序使奇数位于偶数前面
### 29 顺时针打印矩阵
### 31 栈的压入、弹出序列
### 39 数组中出现次数超过一半的数字
### 40 最小的k个数
### 42 连续子数组的最大和
### 47 礼物的最大价值
### 51 数组中的逆序对
### 53 




## 6.3 字符串 12

### 05. 替换空格

### 19.正则表达式匹配

### 20.表示数值的字符串

### 37.序列化二叉树

### 38.字符串的排列

### 45.把数组排成最小的数

### 46.把数字翻译成字符串

### 48.最长不含重复字符的子字符串

### 50.第一个只出现一次的字符

### 58-I.翻转单词顺序

### 58-II.左旋转字符串

### 67.把字符串转换成整数



## 1 数组中重复的数字
## 2 二维数组中的查找

## 数据结构
链表：








字符串的逆序



猴子爬台阶，可以一次走一个台阶或三个台阶，问n个台阶有多少种走法

奥运会奖牌数排序，按照金-银-铜-国家首字母优先级排序

场景题？兔子每隔三个月生一对双胞胎，算法实现？


11、场景题？假设饮料有1块的，2块的，5块的，我有n块钱，我能买多少饮料，算法实现？
