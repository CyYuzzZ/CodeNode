# 1 数据结构问题
## 时间复杂度、空间复杂度

## 线性表
### 顺序表
优点：可随机存储，存储密度高。
缺点：要求连续的内存空间，扩容不方便，插入和删除元素需要移动其他的元素。

### 链表
优点：不要求连续的内存空间，扩容很方便，插入和删除元素不需要移动其他的元素。
缺点：不能随机存储，指针需要消耗空间。



数组和链表的区别？

链表连续存储的使用场景？

栈和队列区别


## 二叉树

二叉树的遍历

## 哈希表

# 2 STL
## 2.1 vector

### 2.1.1 创建

```cpp
vector<double> values;                                  // 创建空double类型的空容器
vector<int> Arrs {1,2,3,4,5,6,7,8,9};                   // 创建整型的容器并初始化  c++11支持，编译参数-std=c++11
vector<int>::const_iterator fist1 = Arrs.begin() + 2; 	// 第三个迭代器
vector<int>::const_iterator last1 = Arrs.end() - 1; 	// 倒数第二个迭代器
vector<int> Arrs2(first1, last1); 			// 创建整型的容器，并初始化为Arrs的第三个到第八个：{3,4,5,6,7,8}
vector<float> Arrs3(5,6.0); 				// 创建浮点型容器，并初始化为5个元素的值均为6.0：{6.0,6.0,6.0,6.0,6.0}

```


### 2.1.2 成员函数

|成员函数|功能|
|-|-|
| size()      | 返回实际元素个数|
| erase()     | 移出一个元素或一段元素(指定范围)   |

```cpp
begin()	                     // 返回指向容器中第一个元素的迭代器。
end()	                     // 返回指向容器最后一个元素所在位置后一个位置的迭代器
empty()	                     // 无元素返回true；反之返回false
push_back()	             // 在序列的尾部添加一个元素。
pop_back()	             // 移出序列尾部的元素。

insert()	             // 在指定的位置插入一个或多个元素
//不常用
rbegin()	                         返回指向最后一个元素的迭代器。
rend()	                         返回指向第一个元素所在位置前一个位置的迭代器。
cbegin()	                      和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。
cend()	                        和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。
crbegin()	和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。
crend()	和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。
max_size()	返回元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。
resize()	改变实际元素的个数。
capacity()	返回当前容量。
reserve()	增加容器的容量。
shrink _to_fit()	将内存减少到等于当前元素实际所使用的大小。
operator[ ]	重载了 [ ] 运算符，可以向访问数组中元素那样，通过下标即可访问甚至修改 vector 容器中的元素。
at()	使用经过边界检查的索引访问元素。
front()	返回第一个元素的引用。
back()	返回最后一个元素的引用。
data()	返回指向容器中第一个元素的指针。
assign()	用新元素替换原有内容。
clear()	移出所有的元素，容器大小变为 0。
swap()	交换两个容器的所有元素。
emplace()	在指定的位置直接生成一个元素。
emplace_back()	在序列尾部生成一个元素。
```

## 2.2 array


## 2.3 list


## 2.4 deque 双端队列
双端队列：

当需要向序列两端频繁的添加或删除元素时，应首选 deque 容器。


## 2.5 stack 栈
栈：仅在表尾插入和删除的线性表，**先进后出**。

开口端称为栈顶。

- 创建
```cpp
// 1 创建一个不包含任何元素的 stack 适配器，并采用默认的 deque 基础容器
stack<int> values;     
// 2 第2个参数指定 vector、deque 和 list 3 个基础容器
stack<string, list<int>> values;   
// 3 用基础容器初始化stack
std::list<int> values {1, 2, 3};
std::stack<int,std::list<int>> my_stack (values);
// 4 用一个stack初始化另一个stack（存储类型相同，基础容器相同）
```

- 成员函数
```cpp
empty()	             // 没有元素返回true；反之返回false。
size()	             // 返回stack栈中存储元素的个数。
top()	               // 返回一个栈顶元素的引用，类型为 T&。如果栈为空，程序会报错。
push(const T& val)	 // 先复制val，再将val 副本压入栈顶。这是通过调用底层容器的 push_back() 函数完成的。
push(T&& obj)	       // 以移动元素的方式将其压入栈顶。这是通过调用底层容器的有右值引用参数的 push_back() 函数完成的。
pop()	               // 弹出栈顶元素。
emplace(arg...)	     // arg... 可以是一个参数，也可以是多个参数，但它们都只用于构造一个对象，并在栈顶直接生成该对象，作为新的栈顶元素。
swap(stack<T> & other_stack)  	// 将两个stack的元素互换，进行互换的2个stack存储的元素类型及基础容器类型都必须相同。
```

## 2.6 queue 队列
队列：先进先出

从最低端加入元素，从最顶端取得元素，不允许有遍历行为。


## 2.7 有序容器

- **创建**

```cpp
set<string> myset;                 // 创建set
multiset<string> mymultiset;      // 创建multiset
```

- **成员函数**

multiset和set成员函数一样。

|成员函数|功能|
|-|-|
|empty()     | 若容器为空，则返回 true；否则 false  |
|count(val)  | 查找值为val的元素的个数，并返回。set的返回值最大为1|
|insert()    | 向 set 容器中插入元素 |

```cpp
begin()	返回指向容器中第一个（注意，是已排好序的第一个）元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。
end()	返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。
rbegin()	返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。
rend()	返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。
cbegin()	和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。
cend()	和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。
crbegin()	和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。
crend()	和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。
find(val)	在 set 容器中查找值为 val 的元素，如果成功找到，则返回指向该元素的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。
lower_bound(val)	返回一个指向当前 set 容器中第一个大于或等于 val 的元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。
upper_bound(val)	返回一个指向当前 set 容器中第一个大于 val 的元素的迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。
equal_range(val)	该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的值为 val 的元素（set 容器中各个元素是唯一的，因此该范围最多包含一个元素）。
	
size()	返回当前 set 容器中存有元素的个数。
max_size()	返回 set 容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同。

erase()	删除 set 容器中存储的元素。
swap()	交换 2 个 set 容器中存储的所有元素。这意味着，操作的 2 个 set 容器的类型必须相同。
clear()	清空 set 容器中所有的元素，即令 set 容器的 size() 为 0。
emplace()	在当前 set 容器中的指定位置直接构造新元素。其效果和 insert() 一样，但效率更高。
emplace_hint()	在本质上和 emplace() 在 set 容器中构造新元素的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示新元素生成位置的迭代器，并作为该方法的第一个参数。

```


## 2.8 无序容器
| 无序容器  |  功能|
|------------|-|
| unordered_map      | 存储键值对 <key, value> 类型的元素，其中各个键值对键的值不允许重复，且该容器中存储的键值对是无序的。|
| unordered_multimap | 和 unordered_map 唯一的区别在于，该容器允许存储多个键相同的键值对。|
| unordered_set	     | 不再以键值对的形式存储数据，而是直接存储数据元素本身（当然也可以理解为，该容器存储的全部都是键 key 和值 value 相等的键值对，正因为它们相等，因此只存储 value 即可）。另外，该容器存储的元素不能重复，且容器内部存储的元素也是无序的。|
| unordered_multiset	|和 unordered_set 唯一的区别在于，该容器允许存储值相同的元素。|


- 创建 unordered_map
```cpp
unordered_map<string, string> umap;

```

- 成员函数

|函数|功能|
|-|-|
|operator[key]	|  该模板类中重载了[]运算符，可以向访问数组中元素那样，只要给定某个键值对的键key，就可以获取该键对应的值。如果当前容器中没有以key为键的键值对，则其会使用该键向当前容器中插入一个新键值对。|
|  |    | 

```cpp
begin()	返回指向容器中第一个键值对的正向迭代器。
end() 	返回指向容器中最后一个键值对之后位置的正向迭代器。
cbegin()	和 begin() 功能相同，只不过在其基础上增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。
cend()	和 end() 功能相同，只不过在其基础上，增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。
empty()	若容器为空，则返回 true；否则 false。
size()	返回当前容器中存有键值对的个数。
max_size()	返回容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。
at(key)	返回容器中存储的键 key 对应的值，如果 key 不存在，则会抛出 out_of_range 异常。 
find(key)	查找以 key 为键的键值对，如果找到，则返回一个指向该键值对的正向迭代器；反之，则返回一个指向容器中最后一个键值对之后位置的迭代器（如果 end() 方法返回的迭代器）。
count(key)	在容器中查找以 key 键的键值对的个数。
equal_range(key)	返回一个 pair 对象，其包含 2 个迭代器，用于表明当前容器中键为 key 的键值对所在的范围。
emplace()	向容器中添加新键值对，效率比 insert() 方法高。
emplace_hint()	向容器中添加新键值对，效率比 insert() 方法高。
insert() 	向容器中添加新键值对。
erase()	删除指定键值对。
clear() 	清空容器，即删除容器中存储的所有键值对。
swap()	交换 2 个 unordered_map 容器存储的键值对，前提是必须保证这 2 个容器的类型完全相等。
bucket_count()	返回当前容器底层存储键值对时，使用桶（一个线性链表代表一个桶）的数量。
max_bucket_count()	返回当前系统中，unordered_map 容器底层最多可以使用多少桶。
bucket_size(n)	返回第 n 个桶中存储键值对的数量。
bucket(key)	返回以 key 为键的键值对所在桶的编号。
load_factor()	返回 unordered_map 容器中当前的负载因子。负载因子，指的是的当前容器中存储键值对的数量（size()）和使用桶数（bucket_count()）的比值，即 load_factor() = size() / bucket_count()。
max_load_factor()	返回或者设置当前 unordered_map 容器的负载因子。
rehash(n)	将当前容器底层使用桶的数量设置为 n。
reserve()	将存储桶的数量（也就是 bucket_count() 方法的返回值）设置为至少容纳count个元（不超过最大负载因子）所需的数量，并重新整理容器。
hash_function()	返回当前容器使用的哈希函数对象。
```







# 3 算法

## 3.1 排序算法

### 00 复杂度比较

|  排序算法  |  平均时间复杂度  |  最坏时间复杂度  |  最好时间复杂度  |  空间复杂度  |  稳定性  |
|------------|-----------------|------------------|------------------|--------------|---------|
|  冒泡排序  | O(n²)          | O(n²)             | O(n)           | O(1)          | 稳定     |
|  选择排序  | O(n²)          | O(n²)             | O(n²)          | O(1)          | 不稳定   |
|  插入排序  | O(n²)          | O(n²)             | O(n)           | O(1)          | 稳定     |
|  希尔排序  | O(nlogn)       | O(nlogn)          | O(n)           | O(1)          | 不稳定   |
|  快速排序  | O(nlogn)       | O(n²)             | O(nlogn)       | O(nlogn)      | 不稳定   |
|  归并排序  | O(nlogn)       | O(nlogn)          | O(nlogn)       | O(n)          | 稳定     |
|  堆排序    | O(nlogn)       | O(nlogn)          | O(nlogn)       | O(1)          | 不稳定   |
|  计数排序  | O(n+k)         | O(n+k)            | O(n+k)         | O(n+k)        | 稳定     |
|  桶排序    | O(n+k)         | O(n²)             | O(n)           | O(n+k)        | 稳定     |
|  基数排序  | O(N* M)        | O(N* M)           | O(N* M)        | O(N+M)        | 稳定     |


### 01 冒泡排序

两个for循环

优化：判断外层一次for循环有没有交换数据，没有则直接结束。

### 02 选择排序

从头到尾扫描序列，找出最小的一个元素，和第一个元素交换，接着从剩下的元素中继续这种选择和交换方式，最终得到一个有序序列。

优化：选择排序一次循环把最大值最小值都选出来，分别放在两端。如果最大值在最左边，交换最小之后，最大值在之前的最小值位置上。

### 03 插入排序

原理：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）

插入排序的缺点：

> （1）寻找插入位置
> 
> （2）移动元素

优化方案：

> （1）对已排好序的序列，采用二分查找方法
> 
> （2）携带多个元素
> 
> （3）数据链表化
> 
> （4）希尔排序

### 04 希尔排序

希尔排序是插入排序的一种，是针对直接插入排序的改进

希尔排序的思想是化远为近：

> （1）查找次数减少
> 
> （2）移动元素的次数减少。

希尔排序的基本思想：把待排序的数列分为多个组，然后再对每个组进行插入排序，先让数列整体大致有序，然后多次调整分组方式，师叔祖更加有序，最后在使用一次插入排序，整个数列将全部有序。

选择增量 gap=length/2，缩小增量以 gap = gap/2 的方式。

### 05 快速排序⭐

- 基本思想

> 先从数列中取出元素作为基准数
> 
> 扫描数列，将比基准数小的元素全部放在它的左边，大于或等于基准数的元素全部放到它的右边，得到左右两个区间
> 
> 在对左右区间重复第二步，直到区间元素少于两个元素

- 实现

```cpp

```

- 优化

> 采用更合理的基准数，减少递归深度。从数列中选取多个数，取中间数
> 
> 结合插入排序，区间在10个以内采用插入排序

### 06 归并排序⭐

将已经有序的子数列合并，得到另一个有序的数列。

用递归或循环实现归并排序

### 07 堆排序⭐

堆排序是利用堆这种数据结构而设计的排序算法。

堆具备以下特点：

> 完全二叉树（每一层都是满的，最下面一层结点集中在最左边）。
> 
> 二叉树每个结点的值都大于或等于其左右子树结点的值，称为大顶堆；每个结点小于或等于其左右子节点时，称为小顶堆。
> 
> N[i]的左节点：N[2i+1]
> 
> N[i]的右节点：N[2i+2]
> 
> N[i]的父节点：N[(i-1)/2]

### 08 计数排序

- 计数排序的条件

> 排序的元素必须是整数
> 
> 排序元素的取值要在一定范围内，并且比较集中

- 优化

> 数组长度定义为 max-min-+1 。

### 09 桶排序 ⭐

- 原理

> 假设输入数据服从均匀分布，将数据分到有限数量的桶里，
> 
> 然后再对每个桶分别排序，
> 
> 最后把全部桶的数据合并。

桶排序的时间复杂度取决于对桶之间数据进行排序的时间复杂度，因为其他部分的时间复杂度都是O(n)。很显然，桶划分的越小，桶里的数据就越少，排序所用时间也会越少，但相应空间消耗会增大。

- 桶思想

> 实际开发中，大部分数据是均匀的，或者在设计的时候可以让他均匀，或者说可以转换为均匀的分布。

### 10 基数排序

基数排序（Radix sort）是桶排序的扩展。

- 思想

> 将整数按位数切割成不同的数字，然后按每个位数分别比较。从低位排到高位，桶先进先出（队列queue）。
> 基数排序可以理解为按关键字排序，如个位十位百位，日期的年月日

```cpp
int main()
{
    int arr[] = {144,203,738,905,347,215,836,26,527,602,946,504,219,750,848};
    int len = sizeof(arr)/sizeof(int), max=0;
    int ret[len]; 
    for(int i=0;i<len;i++){
        if(arr[i]>max) max = arr[i];  // 获取最大值
    }       
    for(int exp=1;max/exp>0;exp=exp*10){
    int count[10] = {0};
        for(int i=0;i<len;i++){
            count[(arr[i]/exp)%10]++;    // 统计个位数/十位数出现次数
        }
        for(int i=1;i<10;i++){
            count[i] = count[i]+count[i-1]; 
        }
        for(int i=len-1;i>=0;i--)
        {   
            int ind = (arr[i]/exp)%10;
            ret[count[ind]-1] = arr[i];
            count[ind]--;
        }
    }
}
```


## 3.2 查找算法



### 3.2.1 二分法



### 3.2.2 二叉树


## 3.3 递归

递归函数嵌套的调用自己，函数的参数和局部变量占用的内存空间在递去的过程中会持续增长，在归来的时候才逐层释放。当递归的深度达到一定量级，可能会造成栈内存空间不足的情况，栈溢出（Core dump）。

函数的调用有时间和空间的开销，一个程序中同时调用的函数个数是有限的。

一般当循环方法容易实现时，应当避免递归。

- 分而治之

> 把一个问题分解成子问题

## 3.4 动态规划

# 4 算法相关问题


# 6 剑指offer

## 6.1 链表 8
### 06 从尾到头打印链表 √          
### 18 删除链表的结点 √
### 22 链表中（删除）倒数第k个节点 √
### 24 反转链表 √
### 25 合并两个排序链表 √
### 35 复杂链表的复制 √
### 52 两个链表的第一个公共节点 √
### 36 二叉搜索树与双向链表


## 6.2 数组 22
### 03 数组中重复的数字 √
### 04 二维数组中的查找 √
### 07 重建二叉树
### 11 旋转数组的最小数字
### 12 矩阵中的路径
### 17 打印从1到最大的n位数
### 21 调整数组顺序使奇数位于偶数前面
### 29 顺时针打印矩阵
### 31 栈的压入、弹出序列
### 39 数组中出现次数超过一半的数字
### 40 最小的k个数
### 42 连续子数组的最大和
### 47 礼物的最大价值
### 51 数组中的逆序对
### 53 




## 6.3 字符串 12

### 05. 替换空格

### 19.正则表达式匹配

### 20.表示数值的字符串

### 37.序列化二叉树

### 38.字符串的排列

### 45.把数组排成最小的数

### 46.把数字翻译成字符串

### 48.最长不含重复字符的子字符串

### 50.第一个只出现一次的字符

### 58-I.翻转单词顺序

### 58-II.左旋转字符串

### 67.把字符串转换成整数



## 1 数组中重复的数字
## 2 二维数组中的查找

## 数据结构
链表：








字符串的逆序



猴子爬台阶，可以一次走一个台阶或三个台阶，问n个台阶有多少种走法

奥运会奖牌数排序，按照金-银-铜-国家首字母优先级排序

场景题？兔子每隔三个月生一对双胞胎，算法实现？


11、场景题？假设饮料有1块的，2块的，5块的，我有n块钱，我能买多少饮料，算法实现？
