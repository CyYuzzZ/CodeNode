# 1 概念
## 1.1 并行和并发

- 并发：在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行。其中两种并发关系分别是同步和互斥。（并发是指同一时刻只能有一条指令执行，但多个进程指令被快速轮换执行，使得在宏观上有多个进程被同时执行的效果--宏观上并行，针对单核处理器）
- 并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生；
- 并行是在不同实体上的多个事件，并发是在同一实体上的多个事件；
## 1.2 同步和异步

- 同步(synchronous)：进程之间的关系不是相互排斥临界资源的关系，而是相互依赖的关系。进一步的说明：就是前一个进程的输出作为后一个进程的输入，当第一个进程没有输出时第二个进程必须等待。具有同步关系的一组并发进程相互发送的信息称为消息或事件。
- 异步(asynchronous)：异步和同步是相对的，同步就是顺序执行，执行完一个再执行下一个，需要等待、协调运行。异步就是彼此独立,在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。**线程就是实现异步的一个方式**。异步是让调用方法的主线程不需要同步等待另一线程的完成，从而可以让主线程干其它的事情。

在多任务操作系统中，同时运行的多个任务可能：
*   都需要访问/使用同一种资源
*   多个任务之间有依赖关系，某个任务的运行依赖于另一个任务

**互斥：**是指散布在不同任务之间的若干程序片断，当某个任务运行其中一个程序片段时，其它任务就不能运行它们之中的任一程序片段，只能等到该任务运行完这个程序片段后才可以运行。最基本的场景就是：一个公共资源同一时刻只能被一个进程或线程使用，多个进程或线程不能同时使用公共资源。

​		**同步：**是指散布在不同任务之间的若干程序片断，它们的运行必须严格按照规定的某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。最基本的场景就是：两个或两个以上的进程或线程在运行过程中协同步调，按预定的先后次序运行。比如 A 任务的运行依赖于 B 任务产生的数据。

​		显然，同步是一种更为复杂的互斥，而互斥是一种特殊的同步。也就是说互斥是两个任务之间不可以同时运行，他们会相互排斥，必须等待一个线程运行完毕，另一个才能运行，而同步也是不能同时运行，但他是必须要按照某种次序来运行相应的线程（也是一种互斥）！因此互斥具有唯一性和排它性，但互斥并不限制任务的运行顺序，即任务是无序的，而同步的任务之间则有顺序关系。

## 1.4 进程和线程概念、区别

1. 进程是最小的资源分配单位，多个线程共享进程的资源；而线程是CPU调度的最小单位，本质上还是进程；
2. 创建进程或撤销进程，系统都要为之分配或回收资源，操作系统开销远大于创建或撤销线程时的开销；
3. 不同进程地址空间相互独立，同一进程内的线程共享同一地址空间。一个进程的线程在另一个进程内是不可见的；
4. 进程间不会相互影响，而一个线程挂掉将可能导致整个进程挂掉；

进程拥有PCB，有独立的地址空间；线程拥有PCB，没有独立的地址空间。

进程线程优缺点

线程

> 可以在一个进程内实现并发。
> 开销少，创建线程比创建进程快。
> 数据通信、数据共享方便，
> 同时也增加了开发的难度、调试编写困难

1、进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。
2、线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。
3、进程和线程的关系：
(1)一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。
(2)资源分配给进程，同一进程的所有线程共享该进程的所有资源。
(3)处理机分给线程，即真正在处理机上运行的是线程。
(4)线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。
4、进程与线程的区别:
(1)调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位
(2)并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行
(3)拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源.
(4) 系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些

## 1.5 进程的状态转换

# 3 进程调度算法

- 先来先服务调度算法

每次调度都是从后备作业（进程）队列中选择一个或多个最先进入该队列的作业（进程），将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。

- 短作业(进程)优先调度算法

短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业（进程），将它们调入内存运行。

- 高优先级优先调度算法

当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程

- 时间片轮转法

每次调度时，把CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几ms 到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。

- 多级反馈队列调度算法

综合前面多种调度算法。

# 4 守护进程、僵尸进程、孤儿进程

**4.1 守护进程介绍**

​		守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是 Linux 中的后台服务进程。它是一个**生存期较长**的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以d结尾的名字。

​		守护进程是个特殊的孤儿进程，这种进程脱离终端，为什么要脱离终端呢？之所以脱离于终端是为了避免进程被任何终端所产生的信息所打断，其在执行过程中的信息也不在任何终端上显示。由于在 Linux 中，每一个系统与用户进行交流的界面称为终端，每一个从此终端开始运行的进程都会依附于这个终端，这个终端就称为这些进程的控制终端，当控制终端被关闭时，相应的进程都会自动关闭。

​		Linux 的大多数服务器就是用守护进程实现的。比如，Internet 服务器 inetd，Web 服务器 httpd 等。

**4.2 守护进程模型**

1) 创建子进程，父进程退出(必须)
   *   所有工作在子进程中进行,形式上脱离了控制终端

2. 在子进程中创建新会话(必须)
   *   setsid()函数
   *   使子进程完全独立出来，脱离控制
3. 改变当前目录为根目录(不是必须)
   *   chdir()函数
   *   防止占用可卸载的文件系统
   *   也可以换成其它路径
4. 重设文件权限掩码(不是必须)
   *   umask()函数
   *   防止继承的文件创建屏蔽字拒绝某些权限
   *   增加守护进程灵活性

5) 关闭文件描述符(不是必须)
   *   继承的打开文件不会用到，浪费系统资源，无法卸载
6) 开始执行守护进程核心工作(必须)
   ​			  守护进程退出处理程序模型
   **4.3 僵尸进程**

**4.4 孤儿进程**

# 5 线程操作

- **线程id**
```cpp
pthread_t thid;
pthread_t pthread_self(void);                  // 获取线程id
int pthread_equal(pthread_t t1, pthread_t t2); // 比较线程id
```

- **创建线程**
```cpp
pthread_create(&thid,NULL,thmain,void* arg)  
// 成功返回0,第二参数为属性
```

- **线程资源回收**
```cpp
pthread_join(thid,void **retval); // 阻塞等待线程结束，第二参数线程退出状态，一般为NULL
```

- **线程分离**
一般情况下，线程终止后，其终止状态一直保留到其它线程调用pthread_join获取它的状态为止。但是线程也可以被置为detach状态，这样的线程一旦终止就立刻回收它占用的所有资源，而不保留终止状态。
不能对一个已经处于detach状态的线程调用pthread\_join，这样的调用将返回EINVAL错误。也就是说，如果已经对一个线程调用了pthread_detach就不能再调用pthread_join了。
```cpp
int pthread_detach(pthread_t thread);
// 使调用线程与当前进程分离，分离后不代表此线程不依赖与当前进程，线程分离的目的是将线程资源的回收工作交由系统自动来完成，
// 也就是说当被分离的线程结束之后，系统会自动回收它的资源。所以，此函数不会阻塞。
```

- **线程退出**
```cpp
void pthread_exit(void *retval);
```

- **线程取消**
```cpp
int pthread_cancel(pthread_t thread);
```


## 5.1 线程终止

- 非正常终止

  > 如果主线程退出，全部线程将强行终止。
  > 
  > 在子线程调用exit()将终止整个进程。
  > 
  > 缺省行为是终止程序的信号将导致整个进程终止。

  在多进程中，子进程core dump掉不影响其他进程。
  
  在多线程中，子进程core dump掉，整个进程终止。

- 正常终止

  > 线程可以简单的从线程函数中返回，返回值是线程的退出码。
  > 
  > 线程可以被同一进程中的其他线程调用 pthread_cancel(线程id) 取消。
  > 
  > 在线程函数中，调用 pthread_exit() 退出。

## 5.2 线程参数传递

> 创建多个线程并不保证哪个线程先运行。
> 
> 不能用全局变量代替线程函数的参数。
> 
> 传递整形时进行数据类型的强制转换。多个参数时用结构体的地址。
> 
> 如果用结构体作为线程返回值，必须保证线程主函数结束后地址仍然有效，所以采用动态分配内存的方法。


## 5.3 线程信号
在多线程程序中，外向进程发送信号不会中断系统调用。
在多线程程序中，信号的处理是所有线程共享的，以最后一个函数为准。
进程中的信号可以送达单个线程，会中断系统调用。
如果某线程因为信号而终止，整个进程将终止。

## 5.4 资源回收

线程有非分离和分离两种状态，线程缺省状态是非分离的，或者称为可连接的，非分离状态的线程终止时，不会释放线程全部的资源。
如果不关心线程的返回状态，把线程的属性设置为分离，线程结束后，由系统回收资源。
- 1 调用 pthread_death() 函数分离线程。
```cpp
pthread_death(线程id)         // 主线程中
pthread_death(pthread_self)  // 子线程中
```

- 2 创建线程前，调用 pthread_attr_setdetachstate() 设置线程的属性。（很少使用）
- 3 线程清理函数pthread_cleanup_push()、pthread_clean_pop() 必须成对书写在同一语句块中。
> 线程终止、语句块结束的时候，清理函数将被执行。
> 
> 线程运行过程中，调用pthread_cancel() 取消后，返回状态是PTHREAD_CALCELED，即-1。


## 5.5 延迟取消和立即取消
- 立即取消：遇到命令即取消
- 延迟取消：直到遇到下一个取消点才能取消，如果没有取消点，则取消不了。
- 可以设置取消点：pthread_testcancel();

# 6 进程、线程资源
## 6.1 进程共享资源
私有：地址空间、堆、全局变量、栈、寄存器
共享：代码段，公共数据，进程目录，进程 ID  共享内存、消息队列、socket连接池、数据库连接池等
## 6.2 线程共享资源
私有：线程栈，寄存器，程序计数器
共享：堆，地址空间，全局变量，静态变量

# 7 线程安全

多个线程在访问共享资源（全局和静态）的时候会冲突（竞争）。

- 原子性、可见性、顺序性

  > 原子性：一个操作（可能包含多个子操作）要么全部执行（生效），要么全部都不执行（都不生效）。
  > 
  > 可见性：当多个线程并发访问共享变量时，一个线程对共享变量的修改，其他线程能够立即看到。
  > 
  > 顺序性：程序执行顺序按照代码的先后顺序执行。

在多线程中造成数据不同步的主要原因是非原子操作和不可见。
## 7.1 volatile
- 保证了变量的内存可见性，让cpu取内存中的数据，不经过缓存。
- 禁止代码重排序。
- 解决不了非原子操作。
## 7.2 原子操作（原子类型）
    原子操作本质是总线锁，cpu与内存通过总线进行数据交换，在操作之前锁住总线，总线索是硬件级别的锁，效率非常高。
    但是只支持整数，应用场景有限。
## 7.3 线程同步（锁）（重点）
### 7.3.1 互斥锁
- 只有加锁和解锁两种状态，确保同一时间只有一个线程访问共享资源。
- 线程在访问共享资源之前进行加锁，访问完成后释放锁。
- 如果某线程持有锁，其他线程就会形成等待队列。

```cpp
//声名锁
pthread_mutex_t mutex;
//初始化锁
int pthread_mutex_init(pthread_mutex_t *restrict mutex,const pthread_mutexattr_t *restrict attr); //参数：互斥锁地址、互斥锁属性
//销毁锁
int pthread_mutex_destroy(pthread_mutex_t *mutex);
//加锁
int pthread_mutex_lock(pthread_mutex_t *mutex);
//解锁
int pthread_mutex_unlock(pthread_mutex_t *mutex);
```

### 7.3.2 自旋锁
- 自旋锁功能和互斥锁相同，不同的是互斥锁在等待所得时候线程会休眠，不消耗cpu，自旋锁会用一个循环不断检查锁是否可用，会消耗cpu资源。
- 自旋锁用于等待时间很短的场景，互斥锁用于等待时间可能比较长的场景。

```cpp
// 声名自旋锁
pthread_spinlock_t spin;
// 初始化自旋锁
pthread_spin_init(&spin,PTHREAD_PROCESS_PRIVATE);
//销毁自旋锁
pthread_spin_destroy(&spin);
// 加锁
pthread_spin_lock(&spin);
// 解锁
pthread_spin_unlock(&spin);
```

### 7.3.3 读写锁
读写锁与互斥锁类似，读写锁允许更高的并发性。
互斥锁只有加锁和不加锁两种状态，同一时间只能由一个线程加锁
读写锁有三种状态：读模式加锁、写模式加锁和不加锁。
- 只要没有线程持有写锁，任意线程都可以申请读锁。
- 只有在不加锁的状态下，才能成功的申请写锁。
特点
- 读写锁适用于对读的次数远大于写的情况。
- linux系统优先考虑读锁，这种实现方式有可能导致写入线程饿死的情况。

```cpp
// 声名读写锁
pthread_rwlock_t rwlock;
// 初始化读写锁
pthread_rwlock_init(&rwlock,NULL);
//销毁读写锁
pthread_rwlock_destroy(&rwlock);
// 读锁
pthread_rwlock_rdlock(&rwlock);
// 写锁
pthread_rwlock_wrlock(&rwlock);
// 解锁
pthread_rwlock_unlock(&rwlock);
```

### 7.3.4 条件变量

互斥锁不同，条件变量是用来等待而不是用来上锁的，条件变量本身不是锁！

条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用，实现生产消费者模型。

条件变量的两个动作：

> 条件不满, 阻塞线程
> 
> 当条件满足, 通知阻塞的线程开始工作


- 声名条件变量
```cpp
pthread_cond_t cond;
```
- 初始化条件变量
```cpp
int pthread_cond_init(&cond,NULL);
```
- 销毁条件变量
```cpp
pthread_cond_destroy(&cond);
```
- 阻塞条件变量
```cpp
pthread_cond_wait(&cond,&mutex);
```
> 把互斥锁解锁 
> 
> 阻塞，等待条件（被唤醒）
> 
> 条件被触发+给互斥锁加锁（原子操作）

- 唤醒线程
```cpp
pthread_cond_signal(&cond);     // 唤醒至少一个阻塞在条件变量上的线程
pthread_cond_broadcast(&cond);  // 唤醒全部阻塞在条件变量上的线程
```



### 7.3.5 信号量
一个非负整数计数器，其数值用于表示空闲临界资源的数量。

申请资源时，信号量减少，表示可用资源减少。P操作

释放资源时，信号量增加，表示可用资源增加。V操作

根据操作信号量值的结果判断是否对公共资源具有访问的权限，当信号量值大于 0 时，则可以访问，否则将阻塞。

信号量数据类型
```cpp
sem_t sem;
```
初始化信号量
```cpp
sem_init(&sem,int pshared,unsigned int value);
// pshared：等于0时，信号量在线程间共享；不等于0时，在进程间共享。
// value：信号量的初始值
```
销毁信号量
```cpp
sem_destroy(&sem);
```
P操作（加锁）
```cpp
sem_wait(&sem);   // 若信号为0，此函数会阻塞
sem_trywait(sem_t *sem);   // 非阻塞
```
V操作（解锁）
```cpp
sem_post(&sem);   // 信号量+1，并唤醒等待线程sem_wait
```
获取信号量的值
```cpp
int sem_getvalue(sem_t *sem, int *sval);  // sval 存放信号量值的地址
```

### 7.3.6 生产消费者模型
 
- 互斥锁+条件变量实现生产消费者模型
线程清理函数
```cpp
pthread_cleanup_push(thcleanup,NULL);   // 函数入栈，参数1为清理函数
pthread_cleanup_pop(1);                 // 清理函数出栈
```
三种情况会调用清理函数：
> 线程还未执行 pthread_cleanup_pop 前，被 pthread_cancel 取消
> 
> 线程还未执行 pthread_cleanup_pop 前，主动执行 pthread_exit 终止
> 
> 线程执行 pthread_cleanup_pop，且 pthread_cleanup_pop 的参数不为 0.


在pthread_cond_wait时执行pthread_cancel后，要先在线程清理函数中解锁已与相应条件变量绑定的mutex,这样是为了保证pthread_cond_wait可以返回到调用线程。

- 信号量实现生产消费者模型

### 7.3.7 死锁
[什么是死锁](https://www.iamshuaidi.com/1367.html)

### 7.3.7 竞争机制
互斥锁：形成等待队列。重新竞争
读写锁：
自旋锁、条件变量、信号量：形成等待队列。

### 7.3.8 多线程访问数据和fd
写日志不能多个线程写入，一个线程把文件指针关了，另一个线程继续写入会出现段错

# 10 虚拟内存
## 10.1 什么是虚拟内存、解决了什么问题
虚拟内存是操作系统内存管理的一种技术，每个进程启动时，操作系统会提供一个独立的虚拟地址空间，这个地址空间是连续的，进程可以很方便的访问内存，这里的内存指的是访问虚拟内存。虚拟内存的目的，一是方便进程进行内存的访问，二是可以使有限的物理内存运行一个比它大很多的程序。

虚拟内存的基本思想：每个程序拥有自己的地址空间，这个空间被分割成很多块，每块称为一页，每一页地址都是连续的地址范围。这些页被映射到物理内存，但不要求是连续的物理内存，也不需要所有的页都映射到物理内存，而是按需分配，在程序片段需要分配内存时由硬件执行映射(通常是 MMU)，调入内存中执行。
虚拟内存为每个进程提供了一个大的、一致的、私有地址空间

# 11 linux系统态和用户态

内核态与用户态：内核态（系统态）与用户态是操作系统的两种运行级别。内核态拥有最高权限，可以访问所有系统指令；用户态则只能访问一部分指令。

什么时候进入内核态：共有三种方式：a、系统调用。b、异常。c、设备中断。其中，系统调用是主动的，另外两种是被动的。

为什么区分内核态与用户态：在CPU的所有指令中，有一些指令是非常危险的，如果错用，将导致整个系统崩溃。比如：清内存、设置时钟等。所以区分内核态与用户态主要是出于安全的考虑。

# 缓冲区溢出
进程调度算法
分业页与分段
物理地址、逻辑地址、虚拟内存
页面置换算法
外中断和一场
用户态和内核态

进程终止的方式

内存分配内存错误
抖动、颠簸现象
内存交换中，被换出的进程保存在哪里

定时器：时间轮（同类解决方案还有时间堆）

信号；实现时需要统一事件源setsockopt函数

中断类型和区别

轮询和中断的区别

进程地址空间有哪几部分

不同进程地址空间内的内核空间内容是否相同
# 面试问题


3、线程死循环会导致所在进程（单线程进程和多线程进程）出现什么问题，有什么影响？出现假死现象（一定会出现假死吗？）
CPU会飙升吗？
4、线程崩溃会导致进程崩溃吗？一定会导致进程崩溃吗？
5、线程崩溃之后会使用什么方式通知进程呢？
