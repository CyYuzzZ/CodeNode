# 1 进程和线程
## 1.1 并行和并发

​		并发：在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行。其中两种并发关系分别是同步和互斥。（并发是指同一时刻只能有一条指令执行，但多个进程指令被快速轮换执行，使得在宏观上有多个进程被同时执行的效果--宏观上并行，针对单核处理器）

## 1.2 同步和异步

- 同步(synchronous)：进程之间的关系不是相互排斥临界资源的关系，而是相互依赖的关系。进一步的说明：就是前一个进程的输出作为后一个进程的输入，当第一个进程没有输出时第二个进程必须等待。具有同步关系的一组并发进程相互发送的信息称为消息或事件。
- 异步(asynchronous)：异步和同步是相对的，同步就是顺序执行，执行完一个再执行下一个，需要等待、协调运行。异步就是彼此独立,在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。**线程就是实现异步的一个方式**。异步是让调用方法的主线程不需要同步等待另一线程的完成，从而可以让主线程干其它的事情。

## 1.1 进程和线程区别

1. 进程是最小的资源分配单位，多个线程共享进程的资源；而线程是CPU调度的最小单位，本质上还是进程；
2. 创建进程或撤销进程，系统都要为之分配或回收资源，操作系统开销远大于创建或撤销线程时的开销；
3. 不同进程地址空间相互独立，同一进程内的线程共享同一地址空间。一个进程的线程在另一个进程内是不可见的；
4. 进程间不会相互影响，而一个线程挂掉将可能导致整个进程挂掉；

进程拥有PCB，有独立的地址空间；线程拥有PCB，没有独立的地址空间。

## 1.2 进程线程优缺点

线程

> 可以在一个进程内实现并发。
> 开销少，创建线程比创建进程快。
> 数据通信、数据共享方便，
> 同时也增加了开发的难度、调试编写困难

进程

> 

# 2 进程间通信

## 2.1 共享内存

## 2.2 套接字



# 3 线程间通信

![image-20220827150753802](C:\Users\CyYu\AppData\Roaming\Typora\typora-user-images\image-20220827150753802.png)

![image-20220827150813781](C:\Users\CyYu\AppData\Roaming\Typora\typora-user-images\image-20220827150813781.png)

![image-20220827150900027](C:\Users\CyYu\AppData\Roaming\Typora\typora-user-images\image-20220827150900027.png)

# 4 线程的创建、终止、参数传递

## 4.1 终止

- 非正常终止

  > 如果主线程退出，全部线程将强行终止。
  >
  > 在子线程调用exit()将终止整个进程。
  >
  > 缺省行为是终止程序的信号将导致整个进程终止。

  在多进程中，子进程core dump掉不影响其他进程。

  在多线程中，子进程core dump掉，整个进程终止。

- 正常终止

  > 线程可以简单的从线程函数中返回，返回值是线程的退出码。
  >
  > 线程可以被同一进程中的其他线程调用 pthread_cancel(线程id) 取消。
  >
  > 在线程函数中，调用 pthread_exit() 退出。

## 4.2 线程参数传递

> 创建多个线程并不保证哪个线程先运行。
>
> 不能用全局变量代替线程函数的参数。
>
> 传递整形时进行数据类型的强制转换。多个参数时用结构体的地址。
>
> 如果用结构体作为线程返回值，必须保证线程主函数结束后地址仍然有效，所以采用动态分配内存的方法。

# 5 守护进程、僵尸进程、孤儿进程

**5.1 守护进程介绍**

​		守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是 Linux 中的后台服务进程。它是一个**生存期较长**的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以d结尾的名字。

​		守护进程是个特殊的孤儿进程，这种进程脱离终端，为什么要脱离终端呢？之所以脱离于终端是为了避免进程被任何终端所产生的信息所打断，其在执行过程中的信息也不在任何终端上显示。由于在 Linux 中，每一个系统与用户进行交流的界面称为终端，每一个从此终端开始运行的进程都会依附于这个终端，这个终端就称为这些进程的控制终端，当控制终端被关闭时，相应的进程都会自动关闭。

​		Linux 的大多数服务器就是用守护进程实现的。比如，Internet 服务器 inetd，Web 服务器 httpd 等。

**5.2 守护进程模型**

1) 创建子进程，父进程退出(必须)
   *   所有工作在子进程中进行,形式上脱离了控制终端

2. 在子进程中创建新会话(必须)
   *   setsid()函数
   *   使子进程完全独立出来，脱离控制
3. 改变当前目录为根目录(不是必须)
   *   chdir()函数
   *   防止占用可卸载的文件系统
   *   也可以换成其它路径
4. 重设文件权限掩码(不是必须)
   *   umask()函数
   *   防止继承的文件创建屏蔽字拒绝某些权限
   *   增加守护进程灵活性

5) 关闭文件描述符(不是必须)
   *   继承的打开文件不会用到，浪费系统资源，无法卸载
6) 开始执行守护进程核心工作(必须)
   ​			  守护进程退出处理程序模型
   **5.3 僵尸进程**

**5.4 孤儿进程**

## 6 进程、线程资源回收

### 6.1 进程资源回收

​		子进程退出时向父进程发送SIGCHLD信号。如果父进程没有处理信号，子进程会因为资源没有被回收而成为僵尸进程。

- 父进程调用wait（）函数等待子进程退出。
- 忽略SIGCHLD信号。
- 在信号处理函数中释放资源。

### 6.2 线程资源回收

​		线程有非分离和分离两种状态，线程缺省状态时非分离的，或者称为可连接的，非分离状态的线程终止时，不会释放线程全部的资源。

​		如果不关心线程的返回状态，把线程的属性设置为分离，线程结束后，由系统回收资源。

  - 调用 pthread_death() 函数分离线程。

```
pthread_death(进程id)         // 主线程中
pthread_death(pthread_self)  // 子线程中
```

  - 创建线程前，调用 pthread_attr_setdetachstate() 设置线程的属性。（很少使用）

​	

​		线程清理函数pthread_cleanup_push()、pthread_clean_pop() 必须成对书写在同一语句块中。

​		线程终止、语句块结束的时候，清理函数将被执行。

​		线程运行过程中，调用pthread_cancel() 取消后，返回状态是PTHREAD_CALCELED，即-1。

延迟取消和立即取消

- 立即取消：遇到命令即取消
- 延迟取消：直到遇到下一个取消点才能取消，如果没有取消点，则取消不了。
- 可以设置取消点：pthread_testcancel();

## 7 线程信号

在多线程程序中，外向进程发送信号不会中断系统调用。

在多线程程序中，信号的处理是所有线程共享的，以最后一个函数为准。

进程中的信号可以送达单个线程，会中断系统调用。

如果某线程因为信号而终止，整个进程将终止。

## 8 线程安全

​		多个线程在访问共享资源（全局和静态）的时候会冲突（竞争）。

- 原子性、可见性、顺序性

  > 原子性：一个操作（可能包含多个子操作）要么全部执行（生效），要么全部都不执行（都不生效）。
  >
  > 可见性：当多个线程并发访问共享变量时，一个线程对共享变量的修改，其他线程能够立即看到。
  >
  > 顺序性：程序执行顺序按照代码的先后顺序执行。

## 5 锁

## 

## 2 线程池



定时器：时间轮（同类解决方案还有时间堆）

信号；实现时需要统一事件源setsockopt函数

读写锁介绍下

中断类型和区别

轮询和中断的区别

进程地址空间有哪几部分

不同进程地址空间内的内核空间内容是否相同

内存泄漏
