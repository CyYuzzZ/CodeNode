# 1 进程和线程
## 1.1 并行和并发

- 并发：在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行。其中两种并发关系分别是同步和互斥。（并发是指同一时刻只能有一条指令执行，但多个进程指令被快速轮换执行，使得在宏观上有多个进程被同时执行的效果--宏观上并行，针对单核处理器）
- 并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生；
- 并行是在不同实体上的多个事件，并发是在同一实体上的多个事件；
## 1.2 同步和异步

- 同步(synchronous)：进程之间的关系不是相互排斥临界资源的关系，而是相互依赖的关系。进一步的说明：就是前一个进程的输出作为后一个进程的输入，当第一个进程没有输出时第二个进程必须等待。具有同步关系的一组并发进程相互发送的信息称为消息或事件。
- 异步(asynchronous)：异步和同步是相对的，同步就是顺序执行，执行完一个再执行下一个，需要等待、协调运行。异步就是彼此独立,在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。**线程就是实现异步的一个方式**。异步是让调用方法的主线程不需要同步等待另一线程的完成，从而可以让主线程干其它的事情。

在多任务操作系统中，同时运行的多个任务可能：
*   都需要访问/使用同一种资源
*   多个任务之间有依赖关系，某个任务的运行依赖于另一个任务

**互斥：**是指散布在不同任务之间的若干程序片断，当某个任务运行其中一个程序片段时，其它任务就不能运行它们之中的任一程序片段，只能等到该任务运行完这个程序片段后才可以运行。最基本的场景就是：一个公共资源同一时刻只能被一个进程或线程使用，多个进程或线程不能同时使用公共资源。

​		**同步：**是指散布在不同任务之间的若干程序片断，它们的运行必须严格按照规定的某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。最基本的场景就是：两个或两个以上的进程或线程在运行过程中协同步调，按预定的先后次序运行。比如 A 任务的运行依赖于 B 任务产生的数据。

​		显然，同步是一种更为复杂的互斥，而互斥是一种特殊的同步。也就是说互斥是两个任务之间不可以同时运行，他们会相互排斥，必须等待一个线程运行完毕，另一个才能运行，而同步也是不能同时运行，但他是必须要按照某种次序来运行相应的线程（也是一种互斥）！因此互斥具有唯一性和排它性，但互斥并不限制任务的运行顺序，即任务是无序的，而同步的任务之间则有顺序关系。
## 1.3 阻塞和非阻塞

## 1.4 进程和线程概念、区别

1. 进程是最小的资源分配单位，多个线程共享进程的资源；而线程是CPU调度的最小单位，本质上还是进程；
2. 创建进程或撤销进程，系统都要为之分配或回收资源，操作系统开销远大于创建或撤销线程时的开销；
3. 不同进程地址空间相互独立，同一进程内的线程共享同一地址空间。一个进程的线程在另一个进程内是不可见的；
4. 进程间不会相互影响，而一个线程挂掉将可能导致整个进程挂掉；

进程拥有PCB，有独立的地址空间；线程拥有PCB，没有独立的地址空间。

进程线程优缺点

线程

> 可以在一个进程内实现并发。
> 开销少，创建线程比创建进程快。
> 数据通信、数据共享方便，
> 同时也增加了开发的难度、调试编写困难

进程

> 
## 1.5 进程的状态转换
# 2 进程间通信

## 2.1 管道

## 2.2 信号量
## 2.3 信号
## 2.4 消息队列
## 2.5 共享内存
## 2.6 套接字



# 3 线程间通信
线程间通信主要用于线程同步
## 3.1 锁机制
## 3.2 信号量
## 3.3 信号机制
## 3.4 屏障


# 4 线程的创建、终止、参数传递

## 4.1 终止

- 非正常终止

  > 如果主线程退出，全部线程将强行终止。
  >
  > 在子线程调用exit()将终止整个进程。
  >
  > 缺省行为是终止程序的信号将导致整个进程终止。

  在多进程中，子进程core dump掉不影响其他进程。

  在多线程中，子进程core dump掉，整个进程终止。

- 正常终止

  > 线程可以简单的从线程函数中返回，返回值是线程的退出码。
  >
  > 线程可以被同一进程中的其他线程调用 pthread_cancel(线程id) 取消。
  >
  > 在线程函数中，调用 pthread_exit() 退出。

## 4.2 线程参数传递

> 创建多个线程并不保证哪个线程先运行。
>
> 不能用全局变量代替线程函数的参数。
>
> 传递整形时进行数据类型的强制转换。多个参数时用结构体的地址。
>
> 如果用结构体作为线程返回值，必须保证线程主函数结束后地址仍然有效，所以采用动态分配内存的方法。

# 5 守护进程、僵尸进程、孤儿进程

**5.1 守护进程介绍**

​		守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是 Linux 中的后台服务进程。它是一个**生存期较长**的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以d结尾的名字。

​		守护进程是个特殊的孤儿进程，这种进程脱离终端，为什么要脱离终端呢？之所以脱离于终端是为了避免进程被任何终端所产生的信息所打断，其在执行过程中的信息也不在任何终端上显示。由于在 Linux 中，每一个系统与用户进行交流的界面称为终端，每一个从此终端开始运行的进程都会依附于这个终端，这个终端就称为这些进程的控制终端，当控制终端被关闭时，相应的进程都会自动关闭。

​		Linux 的大多数服务器就是用守护进程实现的。比如，Internet 服务器 inetd，Web 服务器 httpd 等。

**5.2 守护进程模型**

1) 创建子进程，父进程退出(必须)
   *   所有工作在子进程中进行,形式上脱离了控制终端

2. 在子进程中创建新会话(必须)
   *   setsid()函数
   *   使子进程完全独立出来，脱离控制
3. 改变当前目录为根目录(不是必须)
   *   chdir()函数
   *   防止占用可卸载的文件系统
   *   也可以换成其它路径
4. 重设文件权限掩码(不是必须)
   *   umask()函数
   *   防止继承的文件创建屏蔽字拒绝某些权限
   *   增加守护进程灵活性

5) 关闭文件描述符(不是必须)
   *   继承的打开文件不会用到，浪费系统资源，无法卸载
6) 开始执行守护进程核心工作(必须)
   ​			  守护进程退出处理程序模型
   **5.3 僵尸进程**

**5.4 孤儿进程**

# 6 进程、线程资源
## 6.1 进程共享资源
私有：地址空间、堆、全局变量、栈、寄存器
共享：代码段，公共数据，进程目录，进程 ID
## 6.2 线程共享资源
私有：线程栈，寄存器，程序计数器
共享：堆，地址空间，全局变量，静态变量
### 6.1 进程资源回收

​		子进程退出时向父进程发送SIGCHLD信号。如果父进程没有处理信号，子进程会因为资源没有被回收而成为僵尸进程。

- 父进程调用wait（）函数等待子进程退出。
- 忽略SIGCHLD信号。
- 在信号处理函数中释放资源。

### 6.2 线程资源回收

​		线程有非分离和分离两种状态，线程缺省状态时非分离的，或者称为可连接的，非分离状态的线程终止时，不会释放线程全部的资源。

​		如果不关心线程的返回状态，把线程的属性设置为分离，线程结束后，由系统回收资源。

  - 调用 pthread_death() 函数分离线程。

```
pthread_death(进程id)         // 主线程中
pthread_death(pthread_self)  // 子线程中
```

  - 创建线程前，调用 pthread_attr_setdetachstate() 设置线程的属性。（很少使用）

​	

​		线程清理函数pthread_cleanup_push()、pthread_clean_pop() 必须成对书写在同一语句块中。

​		线程终止、语句块结束的时候，清理函数将被执行。

​		线程运行过程中，调用pthread_cancel() 取消后，返回状态是PTHREAD_CALCELED，即-1。

延迟取消和立即取消

- 立即取消：遇到命令即取消
- 延迟取消：直到遇到下一个取消点才能取消，如果没有取消点，则取消不了。
- 可以设置取消点：pthread_testcancel();

## 7 线程信号

在多线程程序中，外向进程发送信号不会中断系统调用。

在多线程程序中，信号的处理是所有线程共享的，以最后一个函数为准。

进程中的信号可以送达单个线程，会中断系统调用。

如果某线程因为信号而终止，整个进程将终止。

# 8 线程安全

多个线程在访问共享资源（全局和静态）的时候会冲突（竞争）。

- 原子性、可见性、顺序性

  > 原子性：一个操作（可能包含多个子操作）要么全部执行（生效），要么全部都不执行（都不生效）。
  > 可见性：当多个线程并发访问共享变量时，一个线程对共享变量的修改，其他线程能够立即看到。
  > 顺序性：程序执行顺序按照代码的先后顺序执行。

在多线程中造成数据不同步的主要原因是非原子操作和不可见。
## 8.1 volatile
- 保证了变量的内存可见性，让cpu取内存中的数据，不经过缓存。
- 禁止代码重排序。
- 解决不了非原子操作。
## 8.2 原子操作（原子类型）
    原子操作本质是总线锁，cpu与内存通过总线进行数据交换，在操作之前锁住总线，总线索是硬件级别的锁，效率非常高。
    但是只支持整数，应用场景有限。
## 8.3 线程同步（锁）（重点）
### 8.3.1 互斥锁
- 只有加锁和解锁两种状态，确保同一时间只有一个线程访问共享资源。
- 线程在访问共享资源之前进行加锁，访问完成后释放锁。
- 如果某线程持有锁，其他线程就会形成等待队列。
### 8.3.2 自旋锁
自旋锁功能和互斥锁相同，不同的是互斥锁在等待所得时候线程会休眠，不消耗cpu，自旋锁会用一个循环不断检查锁是否可用，会消耗cpu。

自旋锁用于等待时间很短的场景，互斥锁用于等待时间可能比较长的场景。
### 8.3.3 读写锁
读写锁与互斥锁类似，读写锁允许更高的并发性。
互斥锁只有加锁和不加锁两种状态，同一时间只能由一个线程加锁
读写锁有三种状态：读模式加锁、写模式加锁和不加锁。
- 只要没有线程持有写锁，任意线程都可以申请读锁。
- 只有在不加锁的状态下，才能成功的申请写锁。
特点
- 读写锁适用于对读的次数远大于写的情况。
- linux系统优先考虑读锁，这种实现方式有可能导致写入线程饿死的情况。
### 8.3.4 条件变量
和互斥锁一起使用，实现生产消费者模型。
### 8.3.5 信号量
一个整数计数器，其数值用于表示空闲临界资源的数量。
申请资源时，信号量减少，表示可用资源减少。
释放资源时，信号量增加，表示可用资源增加。
### 8.3.6 生产消费者模型
pthread_cond_wait(&cond,&mutex)
- 把互斥锁解锁 
- 阻塞，等待条件（被唤醒）
- 条件被触发+给互斥锁加锁（原子操作）
 
互斥锁+条件变量实现生产消费者模型

消费者函数
```cpp
void *outcache(void *arg)    // 消费者、数据出队线程的主函数。
{
  pthread_cleanup_push(thcleanup,NULL);  // 把线程清理函数入栈。
  struct st_message stmesg;  // 用于存放出队的消息。
  while (true)
  {
    pthread_mutex_lock(&mutex);  // 给缓存队列加锁。
    // 如果缓存队列为空，等待，用while防止条件变量虚假唤醒。
    while (vcache.size()==0)
    {
      pthread_cond_wait(&cond,&mutex);
    } 
    // 从缓存队列中获取第一条记录，然后删除该记录。
   memcpy(&stmesg,&vcache[0],sizeof(struct st_message)); // 内存拷贝。
   vcache.erase(vcache.begin());  
   pthread_mutex_unlock(&mutex);  // 给缓存队列解锁。 
   // 以下是处理业务的代码。
   printf("phid=%ld,mesgid=%d\n",pthread_self(),stmesg.mesgid);
   usleep(100);
 } 
 pthread_cleanup_pop(1);  // 把线程清理函数出栈。
}
```
释放（清理）函数
```cpp
void  thcleanup(void *arg)
{ 
  // 在这里释放关闭文件、断开网络连接、回滚数据库事务、释放锁等等。
  printf("cleanup ok.\n");
   
  pthread_mutex_unlock(&mutex);
  /*
  三种情况会调用清理函数：
      线程还未执行 pthread_cleanup_pop 前，被 pthread_cancel 取消
      线程还未执行 pthread_cleanup_pop 前，主动执行 pthread_exit 终止
      线程执行 pthread_cleanup_pop，且 pthread_cleanup_pop 的参数不为 0.
  
  在pthread_cond_wait时阻塞，执行pthread_cancel后,第一个线程成功退出，互斥锁被锁住。
  要先在线程清理函数中要先解锁已与相应条件变量绑定的mutex,
  这样是为了保证pthread_cond_wait可以返回到调用线程。
  */
}
```



信号量实现生产消费者模型



### 8.3.7 竞争机制
互斥锁：形成等待队列。重新竞争
读写锁：
自旋锁、条件变量、信号量：形成等待队列。
# 9 多线程网络编程
# 10 多线程访问fd
写日志不能多个线程写入，一个线程把文件指针关了，另一个线程继续写入会出现段错误
# 11 线程池

# 缓冲区溢出
进程调度算法
分业页与分段
物理地址、逻辑地址、虚拟内存
页面置换算法
动态链接库、静态链接库
外中断和一场
用户态和内核态

进程终止的方式

内存分配内存错误
抖动、颠簸现象
内存交换中，被换出的进程保存在哪里

定时器：时间轮（同类解决方案还有时间堆）

信号；实现时需要统一事件源setsockopt函数

中断类型和区别

轮询和中断的区别

进程地址空间有哪几部分

不同进程地址空间内的内核空间内容是否相同

