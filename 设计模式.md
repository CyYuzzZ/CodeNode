# 1 什么是设计模式

- 目标：提高复用、应对变化

- **抽象**：为了解决需求的**复杂性**，忽略非本质细节，处理泛化和理想化了的数据模型。

传统的面向对象是：

> 封装、继承、多态

从软件设计层面来看，面向对象是：

> 隔离变化：构建方式更能适应软件的变化，能将变化带来的影响减为最小
> 
> 各司其责：由于需求变化导致的新增类型不应该影响原来类型的实现

## 1.1 设计原则

- 1 依赖倒置原则(DIP)

> 1、上层模块（稳定）不应该依赖底层模块（变化），它们都应该依赖于抽象（稳定）。 
> 
> 2、抽象（稳定）不应该依赖于细节（变化），实现细节应该依赖于抽象（稳定）。

- 2 开放封闭原则(OCP)

> 对扩展开放，对更改封闭。
> 
> 类模块应该是可扩展的，但是不可修改。

- 3 单一职责原则(SPR)

> 一个类应该仅有一个引起它变化的原因。
> 
> 变化的方向隐含着类的责任。

- 4 替换原则（LSP）

> 子类必须能够替换它们的基类（IS-A）。
> 继承表达类型抽象。

- 5 接口隔离原则

> 不应该强迫客户程序依赖它们不用的方法。
> 
> 接口应该小而完备。

- 6 优先使用对象组合，而不是类继承

> 继承在某种程度上破坏了封装性，子类父类耦合度高。
> 
> 而对象组合则只要求被组合的对象具有良好的定义接口，耦合度低。


- 7 封装变化点

> 使用封装来创建对象之间的分界层，让设计者可以在分界层一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。

- 8 针对接口编程，而不是针对实现编程

> 不讲变量类型声明为某个特定的具体类，而是声明为某个接口。
> 客户程序无需获知对象的具体类型，从而实现“高内聚、松耦合”的类型设计方案。

## 1.2 重构关键技法

- 静态 --> 动态

- 早绑定 --> 晚绑定

- 继承 --> 组合

- 编译时依赖 --> 运行时依赖

- 紧耦合 --> 松耦合

# 2 创建型模式

## 2.1 工厂模式⭐

![image](https://user-images.githubusercontent.com/72682213/192424252-9aeed248-1e9d-487c-911b-167904f4906b.png )

![image](https://user-images.githubusercontent.com/72682213/192427856-42c57125-b597-4a10-8133-3372b1ba4da4.png)

![image](https://user-images.githubusercontent.com/72682213/192428878-f18d8650-626c-4bca-b671-6eb3fdc44ced.png)

![image](https://user-images.githubusercontent.com/72682213/192429749-82a3ca63-3e2e-4d0c-b717-d1fc8adceb41.png)

## 2.2 抽象工厂模式⭐

![image](https://user-images.githubusercontent.com/72682213/192450602-aa535891-3d55-4740-931d-2765250f2e7e.png)

![image](https://user-images.githubusercontent.com/72682213/192467400-469f3e83-1c8a-4273-8f4e-b81d864eea8d.png)

![image](https://user-images.githubusercontent.com/72682213/192467453-dfdf41e7-cffa-49e7-9b84-29c91323592a.png)

![image](https://user-images.githubusercontent.com/72682213/192468678-3c1884c4-6bc7-4ca8-85be-8dbb72f414a1.png)

## 2.3 单例模式⭐

- 动机

![image](https://user-images.githubusercontent.com/72682213/192481976-d6347c80-7101-4c60-b48b-55ec83330dab.png)

![image](https://user-images.githubusercontent.com/72682213/192494216-6d67b3b5-02fb-41a6-93ed-d22fb039b694.png)

```cpp
class Singleton{
private:
    Singleton();
    Singleton(const Singleton& other);
public:
    static Singleton* getInstance();
    static Singleton* m_instance;
};
Singleton* Singleton::m_instance=nullptr;

//线程非安全版本
Singleton* Singleton::getInstance() {
    if (m_instance == nullptr) {
        m_instance = new Singleton();
    }
    return m_instance;
}

//线程安全版本，但锁的代价过高
Singleton* Singleton::getInstance() {
    Lock lock;
    if (m_instance == nullptr) {
        m_instance = new Singleton();
    }
    return m_instance;
}

//双检查锁，但由于内存读写reorder不安全
Singleton* Singleton::getInstance() {
    
    if(m_instance==nullptr){
        Lock lock;
        if (m_instance == nullptr) {
            m_instance = new Singleton();
        }
    }
    return m_instance;
}

//C++ 11版本之后的跨平台实现 (volatile)
std::atomic<Singleton*> Singleton::m_instance;
std::mutex Singleton::m_mutex;

Singleton* Singleton::getInstance() {
    Singleton* tmp = m_instance.load(std::memory_order_relaxed);
    std::atomic_thread_fence(std::memory_order_acquire);//获取内存fence
    if (tmp == nullptr) {
        std::lock_guard<std::mutex> lock(m_mutex);
        tmp = m_instance.load(std::memory_order_relaxed);
        if (tmp == nullptr) {
            tmp = new Singleton;
            std::atomic_thread_fence(std::memory_order_release);//释放内存fence
            m_instance.store(tmp, std::memory_order_relaxed);
        }
    }
    return tmp;
}
```

![image](https://user-images.githubusercontent.com/72682213/192494240-89c81828-9e8d-4c59-86ce-68670dbc2bdf.png)



## 2.4 建造者模式⭐

![image](https://user-images.githubusercontent.com/72682213/192476090-b8be8364-7b82-4abe-ba78-14e430fb9bac.png)

![image](https://user-images.githubusercontent.com/72682213/192477336-b4d4d243-32d3-42fb-ade5-e649f6fbaf7e.png)

```cpp
class House{
    //....
};
class HouseBuilder {
public:
    House* GetResult(){
        return pHouse;
    }
    virtual ~HouseBuilder(){}
protected:
    House* pHouse;
    virtual void BuildPart1()=0;
    virtual void BuildPart2()=0;
    virtual void BuildPart3()=0;
    virtual void BuildPart4()=0;
    virtual void BuildPart5()=0;
};

class StoneHouse: public House{
};
class StoneHouseBuilder: public HouseBuilder{
protected:
    virtual void BuildPart1(){
        //pHouse->Part1 = ...;
    }
    virtual void BuildPart2(){  
    }
    virtual void BuildPart3(){ 
    }
    virtual void BuildPart4(){ 
    }
    virtual void BuildPart5(){  
    }
};

class HouseDirector{
public:
    HouseBuilder* pHouseBuilder;
    HouseDirector(HouseBuilder* pHouseBuilder){
        this->pHouseBuilder=pHouseBuilder;
    }
    House* Construct(){  
        pHouseBuilder->BuildPart1();
        for (int i = 0; i < 4; i++){
            pHouseBuilder->BuildPart2();
        }        
        bool flag=pHouseBuilder->BuildPart3();        
        if(flag){
            pHouseBuilder->BuildPart4();
        }        
        pHouseBuilder->BuildPart5();       
        return pHouseBuilder->GetResult();
    }
};
```

![image](https://user-images.githubusercontent.com/72682213/192480287-5177aa93-fcbb-4369-b3c9-8ab1597e70d6.png)


## 2.5 原型模式⭐

![image](https://user-images.githubusercontent.com/72682213/192470112-10691dcd-878c-4dad-9469-7ed419db81ac.png)

![image](https://user-images.githubusercontent.com/72682213/192471787-b4c2195a-6a07-4d69-936c-91a72990184d.png)

```cpp
//抽象类
class ISplitter{
public:
    virtual void split()=0;
    virtual ISplitter* clone()=0; //通过克隆自己来创建对象
    
    virtual ~ISplitter(){}

};

//具体类
class BinarySplitter : public ISplitter{
public:
    virtual ISplitter* clone(){
        return new BinarySplitter(*this);
    }
};

class TxtSplitter: public ISplitter{
public:
    virtual ISplitter* clone(){
        return new TxtSplitter(*this);
    }
};

class PictureSplitter: public ISplitter{
public:
    virtual ISplitter* clone(){
        return new PictureSplitter(*this);
    }
};
/*****************************************************/
class MainForm : public Form
{
    ISplitter*  prototype;  //原型对象
public:
    MainForm(ISplitter*  prototype){
        this->prototype=prototype;
    }
	void Button1_Click(){
		ISplitter* splitter=
            prototype->clone(); //克隆原型
        splitter->split();
	}
};
```

![image](https://user-images.githubusercontent.com/72682213/192472845-e478938f-fa0a-4618-a0cb-bf4e229cfdad.png)

# 3 结构型模式

## 3.1 适配器模式


## 3.2 装饰者模式


## 3.3 代理模式



## 3.4 外观模式


## 3.5 桥接模式


## 3.6 组合模式


## 3.7 享元模式

- 动机
    - 采用纯粹对象方案的问题在于大量细粒度的对象会很快充斥内存，从而带来很高的运行时代价。如何在避免大量细粒度对象问题的同时，让外部客户任然能够透明的使用面向对象的方式进行操作。

- 定义
    - 运用共享技术有效支持大量细粒度的对象  （字符串、线程池）

![image](https://user-images.githubusercontent.com/72682213/192509077-2711028c-923c-4629-a956-51b1a1aa1646.png)

<img src="https://user-images.githubusercontent.com/72682213/192509077-2711028c-923c-4629-a956-51b1a1aa1646.png" width="50%">



# 4 行为型模式

## 4.1 策略模式⭐

定义一系列算法，把他们一个个封装起来，并使它们可互相替换（变化）。该模式使得算法可独立于使用它的客户程序（稳定）而变化（扩展、子类化）。

![image](https://user-images.githubusercontent.com/72682213/192246340-707bff78-5809-486a-ab63-97fa46a589b0.png)

![image](https://user-images.githubusercontent.com/72682213/192246694-4abf385e-12ca-4b00-a639-bedfe494f27a.png)

## 4.2 模板方法模式⭐


## 4.3 观察者模式⭐

- 动机

在软件构建过程中，我们需要为某些对象建立一种“通知依赖关系” ——一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。如果这样的依赖关系过于紧密，将使软件不能很好地抵御变化。

使用面向对象技术，可以将这种依赖关系弱化，并形成一种稳定的依赖关系。从而实现软件体系结构的松耦合。

- 模式定义

定义对象间的一种一对多（变化）的依赖关系，以便当一个对象（subject）的状态发生变化时，所有依赖于它的对象都得到通知并自动更新。

```cpp
class IProgress{   // 观察者基类
public:
	virtual void DoProgress(float value)=0;
	virtual ~IProgress(){}
};
class FileSplitter    // 主体对象
{
	string m_filePath;
	int m_fileNumber;
	List<IProgress*>  m_iprogressList;  // 抽象通知机制，支持多个观察者，容器存放观察者
public:
	FileSplitter(const string& filePath, int fileNumber) :
		m_filePath(filePath), 
		m_fileNumber(fileNumber){
	}
	void split(){
		//1.读取大文件
		//2.分批次向小文件中写入
		for (int i = 0; i < m_fileNumber; i++){
			//...
			float progressValue = m_fileNumber;
			progressValue = (i + 1) / progressValue;
			onProgress(progressValue);   //发送通知
		}
	}
	void addIProgress(IProgress* iprogress){
		m_iprogressList.push_back(iprogress);
	}
	void removeIProgress(IProgress* iprogress){
		m_iprogressList.remove(iprogress);
	}
protected:
	virtual void onProgress(float value){
		
		List<IProgress*>::iterator itor=m_iprogressList.begin();

		while (itor != m_iprogressList.end() )
			(*itor)->DoProgress(value);     //更新进度条  update更新观察者
			itor++;
		}
	}
};

class MainForm : public Form, public IProgress
{
	TextBox* txtFilePath;
	TextBox* txtFileNumber;
	ProgressBar* progressBar;
public:
	void Button1_Click(){
		string filePath = txtFilePath->getText();
		int number = atoi(txtFileNumber->getText().c_str());
		ConsoleNotifier cn;
		FileSplitter splitter(filePath, number);
		splitter.addIProgress(this);    //订阅通知
		splitter.addIProgress(&cn)；    //订阅通知
		splitter.split();
		splitter.removeIProgress(this);
	}
	virtual void DoProgress(float value){    
		progressBar->setValue(value);
	}
};
class ConsoleNotifier : public IProgress {   // 具体的观察者
public:
	virtual void DoProgress(float value){
		cout << ".";
	}
};
```

![image](https://user-images.githubusercontent.com/72682213/192421161-747671f2-8000-4cf5-85c0-33d7fb67065d.png)

![image](https://user-images.githubusercontent.com/72682213/192421675-5ae95c46-6a0c-466c-b08c-46904ca14547.png)

## 4.4 迭代器模式


## 4.5 责任链模式


## 4.6 命令模式


## 4.7 备忘录模式


## 4.8 状态模式


## 4.9 访问者模式


## 4.10 中介者模式


## 4.11 解释器模式










# 单例模式

保证一个类只有一个实例，并且提供一个访问该全局访问点

这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

注意：

1、单例类只能有一个实例。 

2、单例类必须自己创建自己的唯一实例。 

3、单例类必须给所有其他对象提供这一实例。


```cpp
#include <iostream>
using namespace std;

// 单例模式,所使用的类只希望创建一个对象

//------------第一种实现方法，早已存在（饿汉模式）---------------
class A
{
public:
    static A& getInstance() { return a; }   // 始终返回返回唯一A的对象a
    void f() { cout << "A::f()" << endl; } // 外部调用f，A::getInstance().f();
// 构造函数和拷贝构造函数放在private中，外界无法使用，只能在类内部使用，所以外界无法创建对象。
// 只能通过内部创建一个唯一对象返回出去。
private:
    A() { } // 定义构造函数
    A(const A& rhs) { }
    static A a; // 无人创建A的对象时，a已存在,有且只有一个对象a
};
// 定义唯一对象a，因为a在private中声明，但是没有定义，
// 不加这句会报错error: undefined reference to `A::a'
A A::a; 


//------------第二种实现方法，调用才存在（饱汉模式）---------------
class B
{
public:
    static B& getInstance();
    void f() { cout << "B::f()" << endl; }
// 构造函数和拷贝构造函数放在private中，外界无法使用，只能在类内部使用，所以外界无法创建对象。
private:
    B() { }
    B(const B& rhs) { }
};
B& B::getInstance()
{
    // 有调用时才会存在这个对象，且只创建一次，一直存在。
    static B b;
    return b;
}

int main()
{
    //  A::getInstance()是A的单例，A::getInstance().f()是调用此单例的成员函数
    A::getInstance().f(); 
    B::getInstance().f(); 
    return 0;
}
```

