# 1 什么是设计模式

- 目标：提高复用、应对变化

- **抽象**：为了解决需求的**复杂性**，忽略非本质细节，处理泛化和理想化了的数据模型。

传统的面向对象是：

> 封装、继承、多态

从软件设计层面来看，面向对象是：

> 隔离变化：构建方式更能适应软件的变化，能将变化带来的影响减为最小
> 
> 各司其责：由于需求变化导致的新增类型不应该影响原来类型的实现

## 1.1 设计原则

- 1 依赖倒置原则(DIP)

> 1、上层模块（稳定）不应该依赖底层模块（变化），它们都应该依赖于抽象（稳定）。 
> 
> 2、抽象（稳定）不应该依赖于细节（变化），实现细节应该依赖于抽象（稳定）。

- 2 开放封闭原则(OCP)

> 对扩展开放，对更改封闭。
> 
> 类模块应该是可扩展的，但是不可修改。

- 3 单一职责原则(SPR)

> 一个类应该仅有一个引起它变化的原因。
> 
> 变化的方向隐含着类的责任。

- 4 替换原则（LSP）

> 子类必须能够替换它们的基类（IS-A）。
> 继承表达类型抽象。

- 5 接口隔离原则

> 不应该强迫客户程序依赖它们不用的方法。
> 
> 接口应该小而完备。

- 6 优先使用对象组合，而不是类继承

> 继承在某种程度上破坏了封装性，子类父类耦合度高。
> 
> 而对象组合则只要求被组合的对象具有良好的定义接口，耦合度低。


- 7 封装变化点

> 使用封装来创建对象之间的分界层，让设计者可以在分界层一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。

- 8 针对接口编程，而不是针对实现编程

> 不讲变量类型声明为某个特定的具体类，而是声明为某个接口。
> 客户程序无需获知对象的具体类型，从而实现“高内聚、松耦合”的类型设计方案。

## 1.2 重构关键技法

- 静态 --> 动态

- 早绑定 --> 晚绑定

- 继承 --> 组合

- 编译时依赖 --> 运行时依赖

- 紧耦合 --> 松耦合

# 2 创建型模式

## 2.1 工厂模式

![image](https://user-images.githubusercontent.com/72682213/192424252-9aeed248-1e9d-487c-911b-167904f4906b.png )
<img src="[http:...](https://user-images.githubusercontent.com/72682213/192424252-9aeed248-1e9d-487c-911b-167904f4906b.png)" width = 20% height = 20% div align=right />
img src="http:..." width = "100" height = "100" div align=right 

## 2.2 抽象工厂模式

## 2.3 单例模式

## 2.4 建造者模式

## 2.5 原型模式

# 3 结构型模式

## 3.1 适配器模式


## 3.2 装饰者模式


## 3.3 代理模式


## 3.4 外观模式


## 3.5 桥接模式


## 3.6 组合模式


## 3.7 享元模式

# 4 行为型模式

## 4.1 策略模式⭐

定义一系列算法，把他们一个个封装起来，并使它们可互相替换（变化）。该模式使得算法可独立于使用它的客户程序（稳定）而变化（扩展、子类化）。

![image](https://user-images.githubusercontent.com/72682213/192246340-707bff78-5809-486a-ab63-97fa46a589b0.png)

![image](https://user-images.githubusercontent.com/72682213/192246694-4abf385e-12ca-4b00-a639-bedfe494f27a.png)

## 4.2 模板方法模式⭐


## 4.3 观察者模式⭐

- 动机

在软件构建过程中，我们需要为某些对象建立一种“通知依赖关系” ——一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。如果这样的依赖关系过于紧密，将使软件不能很好地抵御变化。

使用面向对象技术，可以将这种依赖关系弱化，并形成一种稳定的依赖关系。从而实现软件体系结构的松耦合。

- 模式定义

定义对象间的一种一对多（变化）的依赖关系，以便当一个对象（subject）的状态发生变化时，所有依赖于它的对象都得到通知并自动更新。

```cpp
class IProgress{   // 观察者基类
public:
	virtual void DoProgress(float value)=0;
	virtual ~IProgress(){}
};
class FileSplitter    // 主体对象
{
	string m_filePath;
	int m_fileNumber;
	List<IProgress*>  m_iprogressList;  // 抽象通知机制，支持多个观察者，容器存放观察者
public:
	FileSplitter(const string& filePath, int fileNumber) :
		m_filePath(filePath), 
		m_fileNumber(fileNumber){
	}
	void split(){
		//1.读取大文件
		//2.分批次向小文件中写入
		for (int i = 0; i < m_fileNumber; i++){
			//...
			float progressValue = m_fileNumber;
			progressValue = (i + 1) / progressValue;
			onProgress(progressValue);   //发送通知
		}
	}
	void addIProgress(IProgress* iprogress){
		m_iprogressList.push_back(iprogress);
	}
	void removeIProgress(IProgress* iprogress){
		m_iprogressList.remove(iprogress);
	}
protected:
	virtual void onProgress(float value){
		
		List<IProgress*>::iterator itor=m_iprogressList.begin();

		while (itor != m_iprogressList.end() )
			(*itor)->DoProgress(value);     //更新进度条  update更新观察者
			itor++;
		}
	}
};

class MainForm : public Form, public IProgress
{
	TextBox* txtFilePath;
	TextBox* txtFileNumber;
	ProgressBar* progressBar;
public:
	void Button1_Click(){
		string filePath = txtFilePath->getText();
		int number = atoi(txtFileNumber->getText().c_str());
		ConsoleNotifier cn;
		FileSplitter splitter(filePath, number);
		splitter.addIProgress(this);    //订阅通知
		splitter.addIProgress(&cn)；    //订阅通知
		splitter.split();
		splitter.removeIProgress(this);
	}
	virtual void DoProgress(float value){    
		progressBar->setValue(value);
	}
};
class ConsoleNotifier : public IProgress {   // 具体的观察者
public:
	virtual void DoProgress(float value){
		cout << ".";
	}
};
```

![image](https://user-images.githubusercontent.com/72682213/192421161-747671f2-8000-4cf5-85c0-33d7fb67065d.png)

![image](https://user-images.githubusercontent.com/72682213/192421675-5ae95c46-6a0c-466c-b08c-46904ca14547.png)

## 4.4 迭代器模式


## 4.5 责任链模式


## 4.6 命令模式


## 4.7 备忘录模式


## 4.8 状态模式


## 4.9 访问者模式


## 4.10 中介者模式


## 4.11 解释器模式














## 2.1 工厂模式

![image](https://user-images.githubusercontent.com/72682213/192216380-9cac1755-7738-4c0e-a430-265ab12a32ee.png)


工厂模式（Factory Pattern）提供了一种创建对象的最佳方式。

在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。









# 单例模式

保证一个类只有一个实例，并且提供一个访问该全局访问点

这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

注意：

1、单例类只能有一个实例。 

2、单例类必须自己创建自己的唯一实例。 

3、单例类必须给所有其他对象提供这一实例。


```cpp
#include <iostream>
using namespace std;

// 单例模式,所使用的类只希望创建一个对象

//------------第一种实现方法，早已存在（饿汉模式）---------------
class A
{
public:
    static A& getInstance() { return a; }   // 始终返回返回唯一A的对象a
    void f() { cout << "A::f()" << endl; } // 外部调用f，A::getInstance().f();
// 构造函数和拷贝构造函数放在private中，外界无法使用，只能在类内部使用，所以外界无法创建对象。
// 只能通过内部创建一个唯一对象返回出去。
private:
    A() { } // 定义构造函数
    A(const A& rhs) { }
    static A a; // 无人创建A的对象时，a已存在,有且只有一个对象a
};
// 定义唯一对象a，因为a在private中声明，但是没有定义，
// 不加这句会报错error: undefined reference to `A::a'
A A::a; 


//------------第二种实现方法，调用才存在（饱汉模式）---------------
class B
{
public:
    static B& getInstance();
    void f() { cout << "B::f()" << endl; }
// 构造函数和拷贝构造函数放在private中，外界无法使用，只能在类内部使用，所以外界无法创建对象。
private:
    B() { }
    B(const B& rhs) { }
};
B& B::getInstance()
{
    // 有调用时才会存在这个对象，且只创建一次，一直存在。
    static B b;
    return b;
}

int main()
{
    //  A::getInstance()是A的单例，A::getInstance().f()是调用此单例的成员函数
    A::getInstance().f(); 
    B::getInstance().f(); 
    return 0;
}
```

