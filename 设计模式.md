

# 2 创建型模式

## 2.1 工厂模式⭐

![image](https://user-images.githubusercontent.com/72682213/192424252-9aeed248-1e9d-487c-911b-167904f4906b.png )

![image](https://user-images.githubusercontent.com/72682213/192427856-42c57125-b597-4a10-8133-3372b1ba4da4.png)

![image](https://user-images.githubusercontent.com/72682213/192428878-f18d8650-626c-4bca-b671-6eb3fdc44ced.png)

![image](https://user-images.githubusercontent.com/72682213/192429749-82a3ca63-3e2e-4d0c-b717-d1fc8adceb41.png)

## 2.2 抽象工厂模式⭐

![image](https://user-images.githubusercontent.com/72682213/192450602-aa535891-3d55-4740-931d-2765250f2e7e.png)

![image](https://user-images.githubusercontent.com/72682213/192467400-469f3e83-1c8a-4273-8f4e-b81d864eea8d.png)

![image](https://user-images.githubusercontent.com/72682213/192467453-dfdf41e7-cffa-49e7-9b84-29c91323592a.png)

![image](https://user-images.githubusercontent.com/72682213/192468678-3c1884c4-6bc7-4ca8-85be-8dbb72f414a1.png)

## 2.3 单例模式⭐

- 动机

![image](https://user-images.githubusercontent.com/72682213/192481976-d6347c80-7101-4c60-b48b-55ec83330dab.png)

![image](https://user-images.githubusercontent.com/72682213/192494216-6d67b3b5-02fb-41a6-93ed-d22fb039b694.png)

```cpp
class Singleton{
private:
    Singleton();
    Singleton(const Singleton& other);
public:
    static Singleton* getInstance();
    static Singleton* m_instance;
};
Singleton* Singleton::m_instance=nullptr;

//线程非安全版本
Singleton* Singleton::getInstance() {
    if (m_instance == nullptr) {
        m_instance = new Singleton();
    }
    return m_instance;
}

//线程安全版本，但锁的代价过高
Singleton* Singleton::getInstance() {
    Lock lock;
    if (m_instance == nullptr) {
        m_instance = new Singleton();
    }
    return m_instance;
}

//双检查锁，但由于内存读写reorder不安全
Singleton* Singleton::getInstance() {
    
    if(m_instance==nullptr){
        Lock lock;
        if (m_instance == nullptr) {
            m_instance = new Singleton();
        }
    }
    return m_instance;
}

//C++ 11版本之后的跨平台实现 (volatile)
std::atomic<Singleton*> Singleton::m_instance;
std::mutex Singleton::m_mutex;

Singleton* Singleton::getInstance() {
    Singleton* tmp = m_instance.load(std::memory_order_relaxed);
    std::atomic_thread_fence(std::memory_order_acquire);//获取内存fence
    if (tmp == nullptr) {
        std::lock_guard<std::mutex> lock(m_mutex);
        tmp = m_instance.load(std::memory_order_relaxed);
        if (tmp == nullptr) {
            tmp = new Singleton;
            std::atomic_thread_fence(std::memory_order_release);//释放内存fence
            m_instance.store(tmp, std::memory_order_relaxed);
        }
    }
    return tmp;
}
```

![image](https://user-images.githubusercontent.com/72682213/192494240-89c81828-9e8d-4c59-86ce-68670dbc2bdf.png)



## 2.4 建造者模式⭐

![image](https://user-images.githubusercontent.com/72682213/192476090-b8be8364-7b82-4abe-ba78-14e430fb9bac.png)

![image](https://user-images.githubusercontent.com/72682213/192477336-b4d4d243-32d3-42fb-ade5-e649f6fbaf7e.png)

```cpp
class House{
    //....
};
class HouseBuilder {
public:
    House* GetResult(){
        return pHouse;
    }
    virtual ~HouseBuilder(){}
protected:
    House* pHouse;
    virtual void BuildPart1()=0;
    virtual void BuildPart2()=0;
    virtual void BuildPart3()=0;
    virtual void BuildPart4()=0;
    virtual void BuildPart5()=0;
};

class StoneHouse: public House{
};
class StoneHouseBuilder: public HouseBuilder{
protected:
    virtual void BuildPart1(){
        //pHouse->Part1 = ...;
    }
    virtual void BuildPart2(){  
    }
    virtual void BuildPart3(){ 
    }
    virtual void BuildPart4(){ 
    }
    virtual void BuildPart5(){  
    }
};

class HouseDirector{
public:
    HouseBuilder* pHouseBuilder;
    HouseDirector(HouseBuilder* pHouseBuilder){
        this->pHouseBuilder=pHouseBuilder;
    }
    House* Construct(){  
        pHouseBuilder->BuildPart1();
        for (int i = 0; i < 4; i++){
            pHouseBuilder->BuildPart2();
        }        
        bool flag=pHouseBuilder->BuildPart3();        
        if(flag){
            pHouseBuilder->BuildPart4();
        }        
        pHouseBuilder->BuildPart5();       
        return pHouseBuilder->GetResult();
    }
};
```

![image](https://user-images.githubusercontent.com/72682213/192480287-5177aa93-fcbb-4369-b3c9-8ab1597e70d6.png)


## 2.5 原型模式⭐

![image](https://user-images.githubusercontent.com/72682213/192470112-10691dcd-878c-4dad-9469-7ed419db81ac.png)

![image](https://user-images.githubusercontent.com/72682213/192471787-b4c2195a-6a07-4d69-936c-91a72990184d.png)

```cpp
//抽象类
class ISplitter{
public:
    virtual void split()=0;
    virtual ISplitter* clone()=0; //通过克隆自己来创建对象
    
    virtual ~ISplitter(){}

};

//具体类
class BinarySplitter : public ISplitter{
public:
    virtual ISplitter* clone(){
        return new BinarySplitter(*this);
    }
};

class TxtSplitter: public ISplitter{
public:
    virtual ISplitter* clone(){
        return new TxtSplitter(*this);
    }
};

class PictureSplitter: public ISplitter{
public:
    virtual ISplitter* clone(){
        return new PictureSplitter(*this);
    }
};
/*****************************************************/
class MainForm : public Form
{
    ISplitter*  prototype;  //原型对象
public:
    MainForm(ISplitter*  prototype){
        this->prototype=prototype;
    }
	void Button1_Click(){
		ISplitter* splitter=
            prototype->clone(); //克隆原型
        splitter->split();
	}
};
```

![image](https://user-images.githubusercontent.com/72682213/192472845-e478938f-fa0a-4618-a0cb-bf4e229cfdad.png)

# 3 结构型模式

## 3.1 适配器模式


## 3.2 装饰者模式


## 3.3 代理模式



## 3.4 外观模式

![image](https://user-images.githubusercontent.com/72682213/192551748-29fd6b8c-6bc4-4df3-9be9-db5f2b520c66.png)

![image](https://user-images.githubusercontent.com/72682213/192551769-32c8601f-45e7-458b-81ec-9f9db0070003.png)

![image](https://user-images.githubusercontent.com/72682213/192552599-357205c5-e76c-4566-a97b-6b039139b37c.png)



## 3.5 桥接模式


## 3.6 组合模式


## 3.7 享元模式⭐

- 动机
    - 采用纯粹对象方案的问题在于大量细粒度的对象会很快充斥内存，从而带来很高的运行时代价。如何在避免大量细粒度对象问题的同时，让外部客户任然能够透明的使用面向对象的方式进行操作。

- 定义
    - 运用共享技术有效支持大量细粒度的对象  （字符串、线程池）

<img src="https://user-images.githubusercontent.com/72682213/192509974-abe47c3d-0d76-4c5d-98ff-49cf300639ac.png" width="70%">

<img src="https://user-images.githubusercontent.com/72682213/192511482-176b8971-88d9-46b6-aee7-eb9b12771406.png" width="70%">

# 4 行为型模式

## 4.1 策略模式⭐



## 4.2 模板方法模式⭐


## 4.3 观察者模式⭐



## 4.4 迭代器模式


## 4.5 责任链模式


## 4.6 命令模式


## 4.7 备忘录模式


## 4.8 状态模式


## 4.9 访问者模式


## 4.10 中介者模式


## 4.11 解释器模式










# 单例模式

保证一个类只有一个实例，并且提供一个访问该全局访问点

这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

注意：

1、单例类只能有一个实例。 

2、单例类必须自己创建自己的唯一实例。 

3、单例类必须给所有其他对象提供这一实例。


```cpp
#include <iostream>
using namespace std;

// 单例模式,所使用的类只希望创建一个对象

//------------第一种实现方法，早已存在（饿汉模式）---------------
class A
{
public:
    static A& getInstance() { return a; }   // 始终返回返回唯一A的对象a
    void f() { cout << "A::f()" << endl; } // 外部调用f，A::getInstance().f();
// 构造函数和拷贝构造函数放在private中，外界无法使用，只能在类内部使用，所以外界无法创建对象。
// 只能通过内部创建一个唯一对象返回出去。
private:
    A() { } // 定义构造函数
    A(const A& rhs) { }
    static A a; // 无人创建A的对象时，a已存在,有且只有一个对象a
};
// 定义唯一对象a，因为a在private中声明，但是没有定义，
// 不加这句会报错error: undefined reference to `A::a'
A A::a; 


//------------第二种实现方法，调用才存在（饱汉模式）---------------
class B
{
public:
    static B& getInstance();
    void f() { cout << "B::f()" << endl; }
// 构造函数和拷贝构造函数放在private中，外界无法使用，只能在类内部使用，所以外界无法创建对象。
private:
    B() { }
    B(const B& rhs) { }
};
B& B::getInstance()
{
    // 有调用时才会存在这个对象，且只创建一次，一直存在。
    static B b;
    return b;
}

int main()
{
    //  A::getInstance()是A的单例，A::getInstance().f()是调用此单例的成员函数
    A::getInstance().f(); 
    B::getInstance().f(); 
    return 0;
}
```

